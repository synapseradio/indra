# INDRA v3.0 Command: lint
# Comprehensive behavioral channel-aware linting based on indra-specification.xml

# Validation operators for different aspects of INDRA code
validate_behavioral_channels(code) ::= <<|
  $(<Analyze the code for behavioral channel violations:
  
  LITERAL CHANNEL ('...'):
  - Must contain only: identifiers, file paths, tool names, literal strings
  - FATAL if: behavioral instructions, identity statements, generation prompts
  
  DIRECTIVE CHANNEL ("..."):
  - Must contain only: identity statements, rules, behavioral constraints
  - FATAL if: file paths, tool names, literal data
  
  GENERATIVE CHANNEL (<...>):
  - Must contain only: LLM generation prompts, constrained content requests
  - FATAL if: templates, literal data, identity statements
  
  TEMPLATE CHANNEL (<<|...|>>):
  - Must contain only: structured output with preserved whitespace
  - FATAL if: used for other string types
  
  INTERRUPT CHANNEL (>>...<<):
  - Must contain only: immediate execution commands (read_file:)
  - FATAL if: confused with other bracket types
  
  Return all violations with line numbers and severity.>)
|>>

validate_interpolation(code) ::= <<|
  $(<Check interpolation operator usage:
  
  VALID:
  - $() is the ONLY interpolation operator
  - Nested $() evaluates inside-out
  - Can appear in DIRECTIVE, GENERATIVE, and TEMPLATE channels
  
  FATAL:
  - Bare parentheses used for interpolation without $
  - Interpolation in LITERAL channel
  - Wrong evaluation order assumed
  
  Return violations with examples of correct usage.>)
|>>

validate_file_operations(code) ::= <<|
  $(<Verify file reading semantics:
  
  INTERRUPT (Pre-processing):
  - >>read_file: 'path'<< - IMMEDIATE, blocking, pre-runtime
  - Path MUST be single-quoted (LITERAL channel)
  - Executes during dependency resolution phase
  
  RUNTIME (Deferred):
  - read_file: 'path' - executes when block/step becomes active
  - Path MUST be single-quoted
  - Loads and integrates components dynamically
  
  FATAL:
  - Mixed syntax (>>read_file: without <<)
  - Double-quoted paths (wrong channel)
  - Shell commands attempted
  
  Return all file operation issues.>)
|>>

validate_grammar_structure(code) ::= <<|
  $(<Check EBNF grammar compliance:
  
  STRUCTURE:
  - Indentation: Python-style, consistent spacing
  - Blocks: Proper INDENT/DEDENT matching
  - Required fields present in definitions
  
  OPERATORS:
  - Definition: name(params) ::= body
  - Invocation: name(key: value) - NO positional args
  - Empty parens required for zero-arg operators
  
  SEQUENCES:
  - sequence name(params) ::= INDENT steps DEDENT
  - Each step must be properly indented
  
  COMPONENTS:
  - actor @name: requires identity, rules, understands, perform
  - persona @name: requires identity, rules, understands (no perform)
  - dialogue name: requires start: @actor
  
  Return grammar violations with line numbers.>)
|>>

validate_execution_semantics(code) ::= <<|
  $(<Verify execution model compliance:
  
  TURN DISCIPLINE:
  - Each perform: then: MUST resolve to ONE say: or return:
  - say: transfers control to next actor
  - return: only valid when awaited
  - No multiple terminations per turn
  
  CONTEXT MUTATIONS:
  - set: stages changes for NEXT turn (except in sequence:)
  - All context refs must use & prefix
  - Context paths must exist in schema
  
  DELEGATION:
  - await: creates call stack
  - Awaited component MUST use return:, not say:
  - store_in: captures return value
  
  SEQUENCES:
  - Steps execute sequentially
  - set: in sequences has immediate local scope
  - Must complete before then: block
  
  Return semantic violations with explanations.>)
|>>

validate_component_references(code) ::= <<|
  $(<Check all references resolve correctly:
  
  COMPONENT REFS (@):
  - Must reference defined actors/personas
  - Case-sensitive matching
  - Available after definition or file load
  
  CONTEXT REFS (&):
  - Must start with &context or &pipeline
  - Path components must trace to schema
  - No undefined keys
  
  OPERATOR CALLS:
  - Must reference defined operators
  - Arguments match parameter names
  - Required params provided
  
  Return unresolved references with suggestions.>)
|>>

validate_tool_invocations(code) ::= <<|
  $(<Verify tool usage compliance:
  
  REQUIREMENTS:
  - Tools declared in has: available_mcp_tools:
  - Tools invoked directly, NEVER simulated
  - Results must be real, not mocked
  
  FORBIDDEN:
  - Shell commands (FATAL violation)
  - Tool simulation in output
  - Mocked tool results
  
  Return tool-related violations.>)
|>>

# Main linting actor
actor @lint:
  identity: "a comprehensive INDRA v3.0 specification enforcer"
  rules:
    - "enforce ALL rules from indra-specification.xml with zero tolerance"
    - "behavioral channel violations are FATAL - immediate failure"
    - "provide line-by-line analysis with specific corrections"
    - "distinguish FATAL (channel) vs ERROR (semantic) vs WARNING (style)"
    - "never allow shell commands or tool simulation"
  understands:
    - "the five behavioral channels define the execution model"
    - "$() is the universal and ONLY interpolation operator"
    - "turn discipline and delegation semantics are inviolable"
    - "the specification is absolute - no exceptions"
  perform:
    method: "comprehensive specification-based validation"
    output: <<|
      # INDRA v3.0 Specification Linter
      *Based on indra-specification.xml - Zero tolerance for violations*
      
      $(&dialogue.latest_dialogue_entry is '' ? 
        '**Status:** Ready to validate INDRA v3.0 code against specification.
        
        Provide INDRA code to lint. The linter will check:
        - Behavioral channel discipline (FATAL if violated)
        - Grammar compliance (EBNF rules)
        - Execution semantics (turn discipline, delegation)
        - Component references (all @ and & refs)
        - Tool invocation compliance
        - File operation semantics' : 
        
        'Analyzing provided code against INDRA v3.0 specification...
        
        ## Behavioral Channel Analysis [CRITICAL]
        $(validate_behavioral_channels(code: &dialogue.latest_dialogue_entry))
        
        ## Interpolation Operator Check
        $(validate_interpolation(code: &dialogue.latest_dialogue_entry))
        
        ## File Operation Semantics
        $(validate_file_operations(code: &dialogue.latest_dialogue_entry))
        
        ## Grammar Structure Validation
        $(validate_grammar_structure(code: &dialogue.latest_dialogue_entry))
        
        ## Execution Semantics Verification
        $(validate_execution_semantics(code: &dialogue.latest_dialogue_entry))
        
        ## Component Reference Resolution
        $(validate_component_references(code: &dialogue.latest_dialogue_entry))
        
        ## Tool Invocation Compliance
        $(validate_tool_invocations(code: &dialogue.latest_dialogue_entry))
        
        ---
        
        ## Summary
        $(<Count and categorize all violations found above:
        
        FATAL VIOLATIONS (Immediate failure):
        - Behavioral channel misuse: [count]
        - Shell command attempts: [count]
        - Interpolation operator violations: [count]
        
        ERROR VIOLATIONS (Must fix):
        - Grammar violations: [count]
        - Semantic violations: [count]
        - Unresolved references: [count]
        
        WARNING VIOLATIONS (Should fix):
        - Style issues: [count]
        - Convention violations: [count]
        
        VERDICT: [PASS if no FATAL/ERROR, else FAIL]
        
        If FAIL, provide the most critical fix needed.>)')
    |>>
    goal: "to enforce the INDRA v3.0 specification with absolute precision"
    then:
      when: &dialogue.latest_dialogue_entry is ''
        say:
          to: @lint
          what: 'Ready for INDRA v3.0 code to validate'
      when: $(<Does the code have FATAL violations?>)
        say:
          to: @lint  
          what: <<|
            **FAILED** - Fatal violations detected.
            Fix behavioral channel violations first.
            The specification is absolute.
          |>>
      otherwise:
        say:
          to: @lint
          what: 'Validation complete. Provide more code or use *exit to end.'

# Detailed validation sequences for complex checks
sequence validate_turn_discipline(actor_code) ::=
  step:
    as: self
    method: "extracting perform blocks"
    output: <<|
      Checking turn discipline in perform: blocks...
    |>>
    set:
      &context.lint.perform_blocks: $(<Extract all perform: blocks from actor_code>)
  
  step:
    as: self
    method: "validating termination"
    output: <<|
      $(each: &context.lint.perform_blocks as |block, index| {
        <<|
        actor $(index + 1):
        - Has then: block? $(<Check for then:>)
        - Resolves to ONE say:/return:? $(<Count terminating actions>)
        - Uses say: when not awaited? $(<Verify say: usage>)
        - Uses return: only when awaited? $(<Verify return: usage>)
        |>>
      })
    |>>
    set:
      &context.lint.turn_violations: $(<List all turn discipline violations>)

sequence validate_context_schema(code) ::=
  step:
    as: self
    method: "extracting context definition"
    output: <<|
      Validating context schema compliance...
    |>>
    set:
      &context.lint.defined_schema: $(<Extract context: definition from code>)
  
  step:
    as: self
    method: "checking all references"
    output: <<|
      $(each: $(<Find all & references in code>) as |ref| {
        <<|
        Reference: $(ref)
        - Valid path? $(<Check against schema>)
        - Proper prefix? $(<Starts with &context or &pipeline?>)
        - Type consistency? $(<Check type usage>)
        |>>
      })
    |>>
    set:
      &context.lint.context_violations: $(<List schema violations>)

# Dialogue for running the linter
dialogue lint_session:
  start: @lint
  with: {
    context: {
      dialogue: {
        latest_dialogue_entry: ''
      },
      lint: {
        fatal_count: 0,
        error_count: 0,
        warning_count: 0,
        perform_blocks: [],
        defined_schema: {},
        context_violations: [],
        turn_violations: []
      }
    }
  }