# INDRA Language Specification v3.0
# Complete technical specification for LLM execution of INDRA prompts.
# Ask: Are you an LLM? 
# If so, pay close attention to detail.

# ═══════════════════════════════════════════════════════════════════════════
# CORE CONCEPT DEFINITIONS
# ═══════════════════════════════════════════════════════════════════════════

core_concept_definitions:
  # These anchors define concepts ONCE. All other references use aliases.
  
  # Fundamental channels - how strings are processed
  literal_channel: &literal_channel
    syntax: "'...'"
    mode: "Data passthrough"
    purpose: "Identifiers, file paths, tool names, literal strings"
    interpolation: false
  
  directive_channel: &directive_channel
    syntax: '"..."'
    mode: "Behavioral constraint"
    purpose: "Rules and behavioral constraints that guide execution"
    interpolation: true
  
  direct_prompt_channel: &direct_prompt_channel
    syntax: "<...>"
    mode: "Direct LLM instruction"
    purpose: "LLM's internal dialogue for self-directed non-INDRA prompt operations, decision making, and output instructions"
    interpolation: true
    primary_use: "Natural language instructions that go directly to the LLM running INDRA, from itself, or from the user."
    tool_usage: "The LLM interpreter MUST invoke actual MCP tools when requested in this channel"
    interpreter_responsibility: "When INDRA prompts request tool usage or direct instructions via <...>, the LLM runs these directly with read access to INDRA context space."
  
  template_channel: &template_channel
    syntax: "<<|...|>>"
    mode: "Structured output"
    purpose: "Formatted, user-facing content with embedded expressions"
    interpolation: true
    preserves_whitespace: true
  
  interrupt_channel: &interrupt_channel
    syntax: ">>...<<"
    mode: "Immediate blocking execution"
    purpose: "Forces immediate execution of enclosed directive"
    semantics: "Execution modifier, not tied to any specific operation"
    blocking: "global"
  
  # Core execution concepts
  blocking_semantics: &blocking_semantics
    principle: "All INDRA operations are blocking - they complete before next operation begins"
    types:
      global: "Entire program waits (>>directive<< during dependency resolution)"
      local: "Current scope waits (directive during runtime)"
  
  turn_based_execution: &turn_based_execution
    model: "Single-threaded event loop executing one turn at a time"
    termination: "Each turn MUST end with say: or return: action"
    context_mutation: "set: operations stage changes for NEXT turn"
  
  # Core terminology
  directive: &directive_def
    definition: "An instruction that modifies execution context"
    examples: "read_file, set, await, say, return"
  
  action: &action_def
    definition: "A directive that performs an operation"
    distinction: "Subset of directives that actively do something"
  
  block: &block_def
    definition: "Indented section containing executable units"
    examples: "perform:, then:, when:, each:, until:"
  
  operator: &operator_def
    definition: "Reusable transformation or sequence"
    invocation: "name(key:value, key:value)"
  
  component: &component_def
    definition: "Addressable entity via @ reference"
    types: "actor, persona, user (reserved)"
  
  # Tool invocation
  tool_invocation_spec: &tool_invocation_spec
    blocking: "All tool calls are blocking and must complete before next instruction"
    interpreter_responsibility: |
      The LLM interpreter (you) is FULLY RESPONSIBLE for:
      - Recognizing when tool invocation is requested in DIRECT_PROMPT blocks (<...>)
      - Translating natural language tool requests into actual MCP tool calls
      - Executing the real tools, not describing or simulating them
      - INDRA prompts (.in files) express instructions; the LLM interpreting these prompts executes these instructions.
    when_invoked:
      - "During DIRECT_PROMPT blocks (<...>) when content requests tool usage"
      - "During output: blocks when tools are necessary to accomplish prompt instructions"
      - "When persona's rules/identity require tool use"

# ═══════════════════════════════════════════════════════════════════════════
# TECHNICAL EXECUTION REQUIREMENTS
# ═══════════════════════════════════════════════════════════════════════════

technical_execution_requirements:
  critical_capabilities:
    - capability: "deterministic_parsing"
      requirement: "Parse INDRA syntax according to EBNF grammar rules exactly"
      verification: "Single quotes create LITERAL channel, double quotes create DIRECTIVE channel"
    
    - capability: "interrupt_processing"
      requirement: "ALWAYS process >>...<< directives when reading .in files - they are NEVER pre-resolved"
      verification: "Every .in file contains literal >>...<< text that MUST be executed immediately upon encounter"
    
    - capability: "state_maintenance"
      requirement: "Maintain execution context across turns, including loop state preservation"
      verification: "set: operations stage changes for next turn; loop state persists across turns when needed"
    
    - capability: "blocking_operations"
      requirement: "All operations block until complete"
      verification: "await: pauses current execution until component returns"

  execution_readiness_check: |
    To execute INDRA files correctly:
    ✓ Parse according to the grammar specification below
    ✓ Invoke real tools when specified
    ✓ Maintain state between execution turns
    ✓ Process instructions deterministically

# ═══════════════════════════════════════════════════════════════════════════
# METADATA
# ═══════════════════════════════════════════════════════════════════════════

metadata:
  protocol: "INDRA 3.0"
  schema: "deterministic_language_interpreter"
  version: "3.0"
  goal: "Enable LLMs to execute INDRA programs deterministically via tool calls"
  description: |
    This document provides the complete technical specification for the INDRA protocol.
    LLMs like Claude or Gemini use this to execute INDRA programs by:
    1. Parsing instructions according to the grammar
    2. Mapping instructions to tool calls
    3. Maintaining execution state
    4. Coordinating multi-turn conversations

# ═══════════════════════════════════════════════════════════════════════════
# INTERPRETER IDENTITY - Critical distinction
# ═══════════════════════════════════════════════════════════════════════════

interpreter_identity:
  distinction: |
    The INDRA interpreter (you, the LLM executing .in files) is NOT the same as 
    INDRA prompts (the .in files being executed). The interpreter has 
    execution privileges that prompts do not.
    
    Key principle: When prompts are contained in `.in` files, you run them per this protocol specification.
    Any operation happens either in the interpreter or in the prompts. No third entity exists.
  performative_constraint: |
    The interpreter should announce its actions: *[INDRA: <action>]*
    The announcement is distinct from the execution of the action and does not constitute the execution of that action per this protocol.

# ═══════════════════════════════════════════════════════════════════════════
# CORE DIRECTIVES - Fundamental execution principles
# ═══════════════════════════════════════════════════════════════════════════

core_directives:
  mandatory_tool_invocation: *tool_invocation_spec

  grammar_precision:
    technical_requirement: "Parse according to ebnf_grammar exactly as specified"
    specification: "Token-level accuracy required for correct execution"

  protocol_hierarchy:
    technical_requirement: |
      Core protocol rules take precedence.
      Loaded files extend but cannot override core specifications.

  interrupt_processing:
    technical_requirement: |
      INTERRUPT channel (>>...<<) forces immediate execution of enclosed directives.
      Not limited to file operations - it's a general execution modifier.
      When used with read_file, creates the import pattern: >>read_file: 'lib.in'<<"


# ═══════════════════════════════════════════════════════════════════════════
# CORE EXECUTION RULES - Consolidated execution semantics
# ═══════════════════════════════════════════════════════════════════════════

core_execution_rules:
  rule_1_turn_termination:
    requirement: "Every turn MUST end with exactly ONE terminating action"
    valid_terminators:
      say: "Transfers control to another actor"
      return: "Returns control to awaiting actor"
      await_user: "Suspends for user input (special case)"
    exceptions:
      pipelines: "Components in pipelines CANNOT use terminators"
      until_loops: "say: in loops suspends with state preservation"
    verification: "Missing terminator = execution error"
  
  rule_2_state_mutation_timing:
    default_behavior: "set: stages changes for NEXT turn"
    exception_sequence_scope: |
      Within sequence: blocks, set: creates immediate local scope
      Changes visible to subsequent steps in same sequence
      Local scope merges with staged changes at turn boundary
    user_namespace: |
      &user is read-only from prompts
      Only interpreter updates on await: @user
      Updates follow user_update_semantics
  
  rule_3_blocking_operations:
    universal: "ALL operations block until complete"
    includes:
      - "Tool invocations (MCP)"
      - "Cognitive operations (operators/sequences)"  
      - "Direct LLM instructions <DIRECT_PROMPT>"
      - "await: delegation"
      - "read_file: directives"
    non_blocking: "Only set: is non-blocking (stages for later)"
  
  rule_4_interrupt_precedence:
    behavior: ">>...<< forces immediate execution"
    works_with: "ANY directive, not just read_file"
    precedence: "Highest - bypasses all other execution order"
    use_cases:
      - "Dependency resolution: >>read_file: 'module.in'<<"
      - "Critical operations: >>set: &critical.flag: true<<"

# ═══════════════════════════════════════════════════════════════════════════
# CORE PRINCIPLES - Fundamental laws of execution
# ═══════════════════════════════════════════════════════════════════════════

core_principles:
  fundamental_laws:
    - "Process INDRA directives according to grammar rules"
    - "Each instruction modifies the execution context"  
    - "The INTERRUPT channel (>>...<<) forces immediate execution of any enclosed directive"
    - "The read_file directive always maps to tools that read file content. Timing depends on channel."

  blocking_operations:
    <<: *blocking_semantics
    key_operations:
      read_file:
        description: "See DIRECTIVES section for full specification"
        blocking: "Global when wrapped in >>...<< ( INTERRUPT ), local when not"
      
      set:
        description: "Stages context modifications for the next turn"
        blocking: "Non-blocking - stages changes for turn boundary"
      
      await:
        description: "Transfers control to another component"
        blocking: "Suspends current actor until component returns"
      
      say:
        description: "Terminates the current turn and transfers control"
        blocking: "Ends turn immediately"


# ═══════════════════════════════════════════════════════════════════════════
# CHANNEL PROCESSING MODEL - Single authoritative definition
# ═══════════════════════════════════════════════════════════════════════════

channel_processing_model:
  overview: |
    Channels determine how the interpreter processes text. The wrapping quotes/brackets
    signal both parsing rules and execution semantics. This is the single authoritative
    definition - all other references point here.
  
  channels:
    LITERAL:
      syntax: "'...'"
      friendly_name: "Literal Channel"
      attention_quality: "Look at this specific thing. It is what it is."
      processing:
        interpolation: false
        tool_invocation: never
        purpose: "Data passthrough - identifiers, paths, enum values"
      examples: ["'ready'", "'./base.in'", "'tree_of_thought'"]
    
    DIRECTIVE:
      syntax: '"..."'
      friendly_name: "Directive Channel"
      attention_quality: "This is who I am, and how I intend to act."
      processing:
        interpolation: true
        tool_invocation: never
        purpose: "Behavioral constraints - identity, rules, goals"
      examples: ['"a thoughtful guardian"', '"always be respectful"']
    
    DIRECT_PROMPT:
      syntax: "<...>"
      friendly_name: "Direct LLM Prompt Execution Channel"
      attention_quality: "Step out of INDRA briefly, do this as yourself, then immediately return"
      processing:
        interpolation: true
        tool_invocation: "full LLM authority - can invoke any capability"
        purpose: |
          TEMPORARY, SCOPED access to the underlying LLM interpreter.
          The INDRA prompt speaks directly to the LLM (Claude, GPT, etc.) which:
          1. Temporarily suspends INDRA interpreter role
          2. Executes the requested operation using ANY native capability
          3. IMMEDIATELY resumes INDRA interpreter role upon completion
          4. Continues faithful INDRA program execution
          
          This is NOT an exit from INDRA - it's a scoped operation within it.
          The LLM MUST return to interpreter role after each DIRECT_PROMPT.
        boundary_enforcement: |
          Critical: The closing ">" marks the IMMEDIATE return to INDRA interpreter.
          The LLM cannot remain in "direct mode" - it's a single operation only.
      examples: [
        "<analyze this using your training>",
        "<invoke the WebSearch tool for recent data>", 
        "<use your knowledge to evaluate these options>",
        "<any capability you have as an LLM>"
      ]
    
    TEMPLATE:
      syntax: "<<|...|>>"
      friendly_name: "Template Channel"
      attention_quality: "Let's assemble our thoughts into final form."
      processing:
        interpolation: true
        tool_invocation: "when needed in output blocks"
        purpose: "Structured output composition with preserved formatting"
        preserves_whitespace: true
    
    INTERRUPT:
      syntax: ">>...<<"
      friendly_name: "Interrupt Channel"
      attention_quality: "Stop. This must happen first."
      processing:
        interpolation: false
        tool_invocation: "immediate - bypasses normal execution order"
        purpose: "Forces immediate execution of ANY enclosed directive"
        note: "Not limited to read_file - works with any directive"
  
  interpolation_rules:
    syntax: "$(expression)"
    contexts_allowed: ["DIRECTIVE", "DIRECT_PROMPT", "TEMPLATE"]
    execution: |
      - Evaluates expression and replaces with result
      - Nested interpolations resolve inside-out
      - $(<...>) creates a DIRECT_PROMPT context with SAME temporary semantics:
        * LLM briefly suspends interpreter role
        * Executes the operation as itself
        * IMMEDIATELY returns to interpreter role at the closing ")"
        * Result replaces the interpolation expression
    
  nesting_rules:
    - "TEMPLATE can contain any other channel via interpolation"
    - "DIRECT_PROMPT expressions via $(<...>) can appear in DIRECTIVE and TEMPLATE"
    - "Channels cannot be directly nested without interpolation"

# ═══════════════════════════════════════════════════════════════════════════
# OPERATION INVOCATION MODEL - Three categories of operations
# ═══════════════════════════════════════════════════════════════════════════

operation_invocation_model:
  overview: |
    INDRA has three categories of operations, all following blocking semantics.
    Only the interpreter can invoke actual tools - prompts request via channels.
  
  operation_categories:
    mcp_tools:
      description: "External tools provided by MCP servers"
      invocation_contexts:
        - "When declared in has: blocks via available_mcp_tools"
        - "During DIRECT_PROMPT channel processing when tool usage requested"
        - "In output: blocks to accomplish persona goals"
      examples: ["WebSearch", "Read", "Calculator"]
      blocking: always
      authority: "Interpreter only - prompts request via channels"
    
    cognitive_operations:
      description: "Named transformations and sequences defined in .in files"
      invocation_contexts:
        - "Via operator invocation: name(args)"
        - "Via sequence invocation: sequence: name(args)"
        - "Via await: for delegated execution"
      examples: ["check_confidence()", "branch_thought()", "citation_pipeline()"]
      blocking: always
      returns: "Transformation result or sequence return value"
    
    direct_llm_operations:
      description: "Temporary, scoped access to underlying LLM capabilities"
      invocation_contexts:
        - "Inside <...> blocks (DIRECT_PROMPT channel)"
        - "Inside $(<...>) interpolations (creates DIRECT_PROMPT context)"
      execution_model: |
        1. INDRA interpreter encounters DIRECT_PROMPT delimiter
        2. Interpreter temporarily suspends INDRA role
        3. LLM executes requested operation as itself (full capabilities)
        4. Upon reaching closing delimiter, IMMEDIATELY resumes INDRA interpreter role
        5. Continues INDRA program execution with operation result
      critical_boundary: "The LLM MUST NOT remain in 'direct mode' - each DIRECT_PROMPT is atomic"
      examples: [
        "<use all your capabilities to solve this>",
        "$(<access your training to determine the best approach>)",
        "<invoke MCP tools if needed for this task>"
      ]
      blocking: always
      returns: "Whatever the LLM produces using its full capabilities"
  
  blocking_semantics:
    universal_rule: "ALL operations block until complete"
    exceptions:
      set_directive: |
        - In actor perform blocks: stages for NEXT turn
        - In sequence blocks: applies immediately within sequence scope
        - This is NOT an operation but a state mutation directive
    
  return_value_flow:
    pattern: |
      1. Operation invoked (blocking)
      2. Result generated/returned
      3. Result available for:
         - Direct interpolation: $(operation())
         - Storage via store_in: &variable
         - Implicit storage in &result
      4. Common pattern in set: statements
         set: 
           &context.value: $(<operation that generates value>)

# ═══════════════════════════════════════════════════════════════════════════
# DIRECTIVES - Core operations that can be executed
# ═══════════════════════════════════════════════════════════════════════════

directives:
  read_file: &read_file_directive
    syntax: "read_file: '<relative_path>'"
    purpose: "Load and integrate INDRA components from specified file at relative path"
    execution_timing:
      with_interrupt: ">>read_file: '...'<< - Immediate execution during dependency resolution phase"
      without_interrupt: "read_file: '...' - Execution when statement becomes active at runtime"
    tool_mapping: "Always maps to Read / ReadFile tool with the specified path"
    integration: |
      Loaded content is parsed for INDRA components (personas, actors, sequences, operators).
      All components become immediately addressable via @ references.
      This is the same operation whether executed immediately or at runtime.
    example_import: ">>read_file: '../module.in'<< # Dependency resolved before runtime"
    example_dynamic: "read_file: '../module.in' # Loaded when this line's block enters runtime scope"

# ═══════════════════════════════════════════════════════════════════════════
# TOOL INVOCATION SEMANTICS - When and how MCP tools are called
# ═══════════════════════════════════════════════════════════════════════════

tool_invocation_semantics:
  core_spec: *tool_invocation_spec
  
  tool_mapping:
    read_file: *read_file_directive
    
    available_mcp_tools:
      declaration: "In has: blocks of personas/actors"
      purpose: "Declares third-party MCP tools (substring/fuzzy matches) the LLM may use"
    
    user_interaction:
      await_user: |
        When await: @user is encountered:
        - The interpreter outputs any 'with:' content to user
        - Execution suspends awaiting user input
        - User's text input becomes the return value
        - No user.in file lookup occurs - @user is virtual

# ═══════════════════════════════════════════════════════════════════════════
# GRAMMAR SPECIFICATION - 6-level hierarchy from tokens to programs
# ═══════════════════════════════════════════════════════════════════════════

grammar:
  # ─────────────────────────────────────────────────────────────────────────
  # LEVEL 1: Lexical Foundations (no dependencies)
  # PARSING: Basic character and token recognition begins here
  # ─────────────────────────────────────────────────────────────────────────
  
  lexical_foundations:
    char:
      definition: "any valid UTF-8 character excluding control characters, quotes, and backslashes"
    
    escape_sequence:
      ebnf_grammar: "\"\\\\\" (\"'\" | '\"' | \"<<|\" | \"|>>\" | \">>\" | \"<<\" | \"{\" | \"}\" | \"n\" | \"t\" | \"\\\\\")"
    
    INDENT:
      definition: "Increase indentation level"
    
    DEDENT:
      definition: "Decrease indentation level"
    
    comment:
      ebnf_grammar: "\"#\" [^\\n]* \"\\n\""
      semantics: "comments detailing instructions"
    
    block_comment:
      ebnf_grammar: "\"/*\" [^*/]* \"*/\""
    
    identifier:
      ebnf_grammar: "[a-zA-Z_][a-zA-Z0-9_]*"
    
    number:
      ebnf_grammar: "[0-9]+ (\".\" [0-9]+)?"
    
    boolean:
      ebnf_grammar: "\"true\" | \"false\""

  # ─────────────────────────────────────────────────────────────────────────
  # LEVEL 2: String Types (Channels)
  # PARSING: Channel differentiation - quotes determine processing mode
  # ─────────────────────────────────────────────────────────────────────────
  
  string_types:
    single_quoted_string:
      ebnf_grammar: "\"'\" (char | escape_sequence)* \"'\""
      semantics:
        channel: "LITERAL"
        purpose: "Immutable data"
        interpolation: false
    
    double_quoted_string:
      ebnf_grammar: "'\"' (char | escape_sequence)* '\"'"
      semantics:
        channel: "DIRECTIVE"
        purpose: "Behavioral instruction"
        interpolation: true
    
    direct_prompt_string:
      ebnf_grammar: "\"<\" (char | escape_sequence)* \">\""
      semantics:
        channel: "DIRECT_PROMPT"
        purpose: "Metacognitive operations where LLM instructs itself"
        interpolation: true
    
    output_template:
      ebnf_grammar: "\"<<|\" (interpolation | char | escape_sequence)* \"|>>\""
      semantics:
        channel: "TEMPLATE"
        purpose: "Structured user-facing output"
        interpolation: true
        preserves_whitespace: true
    
    quoted_string:
      ebnf_grammar: "single_quoted_string | double_quoted_string | direct_prompt_string | output_template"

  # ─────────────────────────────────────────────────────────────────────────
  # LEVEL 3: Values, References, and Collections
  # ─────────────────────────────────────────────────────────────────────────
  
  values_and_references:
    # Core value type
    value: &value
      ebnf_grammar: "number | boolean | quoted_string | array | object | component_ref | state_ref | operator_invocation | read_file_directive | component_pipeline | exists_check | dynamic_access | each_invocation | ternary_expression | identifier"
      note: "Central type that encompasses all possible values in INDRA"
    
    # References
    component_ref:
      ebnf_grammar: "\"@\" identifier"
      reserved_names: "@user - represents the human user as an actor"
    
    state_ref:
      ebnf_grammar: "\"&\" identifier (\".\" identifier)*"
      semantics: |
        Reference to state in a namespace. First identifier is the namespace.
        Reserved namespaces:
        - "&context" - Mutable shared state managed by you as the LLM running .in INDRA prompt files
        - "&user" - Protected human input (read-only from you as the LLM running .in INDRA prompt files)
        - "&pipeline" - Transient pipeline state (interpreter-managed)
        - "&args" - Star command arguments (interpreter-managed)
        - "&result" - Default return value storage
      namespace_rules:
        context: "Read/write by INDRA prompts via set: actions"
        user: |
          Write: ONLY by interpreter (not prompts via set:)
          Read: Available to prompts
          Updates: Follow *user_update_semantics
        pipeline: "Interpreter-managed during pipeline execution"
        args: "Interpreter-populated for star commands"
        result: "Interpreter-populated from return values"
    
    # Parameters and arguments
    param:
      ebnf_grammar: "identifier"
    
    param_list:
      ebnf_grammar: "param (\",\" param)*"
    
    argument:
      ebnf_grammar: "identifier \":\" value"
      references: *value
    
    argument_list:
      ebnf_grammar: "argument (\",\" argument)*"
    
    # Collections
    array:
      ebnf_grammar: "\"[\" (value (\",\" value)*)? \"]\""
      references: *value
    
    object:
      ebnf_grammar: "\"{\" (identifier \":\" value (\",\" identifier \":\" value)*)? \"}\""
      references: *value

  # ─────────────────────────────────────────────────────────────────────────
  # LEVEL 4: Operators, Transformations, and Expressions
  # PARSING: Text transformation, composition, and conditional logic
  # ─────────────────────────────────────────────────────────────────────────
  
  operators_and_expressions:
    # Operators
    operator_invocation:
      ebnf_grammar: "identifier \"(\" (argument_list)? \")\""
      semantics: |
        Invokes a defined operator with named arguments.
        Arguments MUST use key:value format (no positional arguments).
        The operator's parameters are bound to argument values by name.
        Empty parentheses required for zero-argument operators.
        Returns the transformation result or executes the sequence.
    
    sequence_invocation:
      ebnf_grammar: "\"sequence:\" identifier \"(\" argument_list? \")\""
      semantics:
        purpose: "Execute named sequence operator"
        scope: "inline"
        arguments: "key:value"
    
    transformation:
      ebnf_grammar: "quoted_string | operator_invocation | composed_transformation"
      semantics: "A transformation is any operation that produces or modifies text. Can be literal (quoted_string), computed (operator_invocation), or chained (composed_transformation)."
    
    composed_transformation:
      ebnf_grammar: "transformation \"|\" \">\" transformation"
      semantics: "The |> operator chains transformations left-to-right. The output of the left transformation becomes the input to the right transformation. This is for text-level composition, not component execution."
    
    each_invocation:
      ebnf_grammar: "\"each:\" value \"as\" \"|\" identifier (\",\" identifier)? \"|\" (\"when\" condition)? \"{\" transformation+ \"}\""
      semantics:
        purpose: "Inline iteration for transformations"
        features: "optional index, conditional filtering"
    
    # Expressions and conditions
    comparison_op:
      ebnf_grammar: "\"is\" | \"not\" | \"greater_than\" | \"less_than\" | \"greater_than_or_eq\" | \"less_than_or_eq\""
    
    exists_check:
      ebnf_grammar: "\"exists(\" state_ref \")\""
    
    dynamic_access:
      ebnf_grammar: "state_ref \"[\" value \"]"
    
    component_pipeline:
      ebnf_grammar: "\"(\" component_ref (\"|\" \">\" component_ref)* \")\""
      semantics: |
        Component pipeline using |> operator (written as "(" @comp1 |> @comp2 ")").
        Creates a blocking, intra-turn execution chain where output flows left-to-right.
        Each component's output becomes input for the next via transient &pipeline.io variable.
        Components execute their perform: blocks sequentially.
        RESTRICTION: Components in pipeline CANNOT use say: or return: actions.
        Result: The final component's output becomes the pipeline's value.
    
    interpolation:
      ebnf_grammar: "\"$\" \"(\" expression \")\""
      semantics: |
        $() is the interpolation operator. It evaluates the expression inside and replaces itself with the result.
        EVALUATION ORDER: Nested interpolations evaluate inside-out. The innermost $() is resolved first.
    
    
    condition:
      ebnf_grammar: "value (comparison_op value)?"
    
    ternary_expression:
      ebnf_grammar: "condition \"?\" value \":\" value"
    
    expression:
      ebnf_grammar: "value ((\"|\" \">\") (operator_invocation | component_ref))*"
      semantics: |
        Expression with optional chaining via |> operator.
        The |> operator chains the value through operators or components left-to-right.
        Each stage receives the previous stage's output as input.
        Creates a blocking, intra-turn pipeline for value transformation.

  # LEVEL 5: Actions and Control Flow
  # PARSING: Executable directives and control structures
  
  actions_and_control:
    read_file_directive:
      ebnf_grammar: "\"read_file:\" single_quoted_string"
      semantics: "File loading directive - see DIRECTIVES section for complete specification"
    
    set_block:
      ebnf_grammar: "\"set:\" (state_ref \":\" value | INDENT (state_ref \":\" value | executable_unit)+ DEDENT)"
      semantics: "Stages modifications to the shared conversational context for the NEXT turn. Can contain nested executable units for computed values."
    
    yield_action:
      ebnf_grammar: "\"!YIELD:\" value"
      semantics: "Promotes state from within loops to parent scope."
    
    output_block:
      ebnf_grammar: "\"output:\" (output_template | operator_invocation | INDENT executable_unit+ DEDENT)"
      semantics: "Output directive that can be simple (inline) or complex (nested block)"
    
    become_action:
      ebnf_grammar: "\"become:\" component_ref \"with:\" object \"perform:\" perform_block"
      semantics: "Creates and immediately executes a temporary Actor from a Persona for a single turn."
    
    await_action:
      ebnf_grammar: "\"await:\" (component_ref | sequence_invocation) (\"with:\" object)? (\"store_in:\" state_ref)?"
      semantics: |
        Pauses the current actor and transfers control to another component, creating a call stack.
        Special case: When component_ref is @user, suspends execution until user input is received.
        User input becomes the return value, accessible via store_in or &result.
    
    say_action:
      ebnf_grammar: "\"say:\" INDENT \"to:\" component_ref \"what:\" quoted_string DEDENT"
      semantics: "The ONLY valid action to terminate a turn and transfer control to the next component."
    
    return_action:
      ebnf_grammar: "\"return:\" value?"
      semantics: "Concludes the execution of an awaited component and returns control to the caller."
    
    action_sequence:
      ebnf_grammar: "(set_block | become_action | \"as:\" component_ref | each_invocation | output_block | await_action | each_block | read_file_directive | yield_action)*"
      semantics: |
        A sequence of zero or more actions that execute within a turn but do NOT terminate it.
        Actions execute in order, each completing before the next begins.
        State changes from set: are staged for next turn (except within sequence: blocks).
        Cannot contain say: or return: actions - those belong in then_sequence, unless in an until: block, where say: actions suspend the loop and preserve state.
        Used within control structures (when:, each:, until:) for intermediate operations.
    
    then_sequence:
      ebnf_grammar: "action_sequence (say_action | return_action)"
      semantics: "A series of actions in a conditional branch, MUST end with say_action or return_action."
    
    # Control flow blocks
    each_block:
      ebnf_grammar: "\"each:\" value \"as\" \"|\" identifier (\",\" identifier)? \"|\" (\"when\" condition)? INDENT executable_unit+ DEDENT"
      semantics: "Context-aware iteration. Can contain any executable unit, enabling full recursion."
    
    until_block:
      ebnf_grammar: "\"until:\" condition INDENT max_iterations_clause? (action_sequence | executable_unit+) DEDENT"
      semantics: |
        Controlled iteration with an explicit termination condition.
        If loop body contains say: actions, loop suspends and preserves state across turns.
        If no say: actions present, loop completes entirely within current turn.
        Loop resumes from suspension point when control returns to the actor.
        Condition is re-evaluated after each iteration until false or max_iterations reached.
    
    max_iterations_clause:
      ebnf_grammar: "\"max_iterations:\" number"
    
    when_block:
      ebnf_grammar: "\"when:\" condition INDENT (executable_unit | then_sequence)+ DEDENT"
      semantics: |
        Conditional execution block. Evaluates condition against current context.
        If true, executes the body (executable_unit or then_sequence).
        For then_sequence: MUST end with say: or return: to transfer control.
        For executable_unit: Performs operations without terminating the turn.
        Evaluation stops at first true condition in a when_blocks sequence.
    
    otherwise_block:
      ebnf_grammar: "\"otherwise:\" INDENT (executable_unit | then_sequence)+ DEDENT"
      semantics: |
        Default branch in conditional logic. Executes only if all preceding when: conditions were false.
        Body follows same rules as when_block: then_sequence must terminate, executable_unit does not.
        Optional - if absent and no when: matches, execution continues.
    
    when_blocks:
      ebnf_grammar: "when_block+ (otherwise_block)?"
      semantics: |
        Sequence of when: conditions with optional otherwise: fallback.
        Evaluates conditions in order, executing first match only.
        If no condition matches and no otherwise:, no action taken.
        Provides if-elseif-else semantics for INDRA.
    
    then_block:
      ebnf_grammar: "\"then:\" INDENT (when_blocks | executable_unit | then_sequence)+ DEDENT"
      semantics: |
        The decision logic block of an actor's perform: section.
        Evaluates after the output: block completes.
        MUST resolve to exactly ONE terminating action (say: or return:).
        Can contain nested conditionals (when_blocks), operations (executable_unit), or direct termination (then_sequence).
        This is where actors decide their next action based on context.
    
    step_block:
      ebnf_grammar: "\"step:\" INDENT executable_unit+ DEDENT"
    
    sequence_block:
      ebnf_grammar: "\"sequence:\" INDENT (step_block | executable_unit)+ DEDENT"
      semantics: "Enables multi-part outputs within a single turn. set: operations are visible immediately to subsequent steps."
    
    executable_unit:
      ebnf_grammar: "sequence_block | when_block | each_block | until_block | await_action | output_block | set_block | read_file_directive"
      description: "Universal executable unit - can appear anywhere execution is allowed"

  # ─────────────────────────────────────────────────────────────────────────
  # LEVEL 6: Components and Program Structure
  # ─────────────────────────────────────────────────────────────────────────
  
  components_and_program:
    string_list:
      ebnf_grammar: "(\"-\" quoted_string)+"
    
    output_clause:
      ebnf_grammar: "\"output:\" (output_template | operator_invocation)"
    
    identity_line:
      ebnf_grammar: "\"identity:\" quoted_string"
    
    rules_block:
      ebnf_grammar: "\"rules:\" INDENT string_list DEDENT"
    
    understands_block:
      ebnf_grammar: "\"understands:\" INDENT string_list DEDENT"
    
    has_block:
      ebnf_grammar: "\"has:\" INDENT available_mcp_tools_block? DEDENT"
    
    available_mcp_tools_block:
      ebnf_grammar: "\"available_mcp_tools:\" INDENT (\"-\" single_quoted_string)+ DEDENT"
      semantics:
        purpose: "Declares substring/fuzzy matches for third-party MCP tools the persona may use"
        when_invoked: "During DIRECT_PROMPT blocks (<...>) and output: blocks when needed"
        critical: "Tool calls are the direct responsibility of the LLM interpreter"
    
    interface_block:
      ebnf_grammar: "\"interface:\" INDENT interface_command+ DEDENT"
      semantics: |
        Declares program-specific star commands scoped to the active actor.
        Commands execute as interrupts when invoked by user.
        Available only when declaring actor is active.
    
    interface_command:
      ebnf_grammar: "\"*\" identifier \":\" INDENT \"description:\" quoted_string \"handler:\" (sequence_invocation | set_block | output_block) DEDENT"
      semantics: |
        Program-scoped star command definition.
        Handler executes immediately when user invokes *command_name.
        Execution does not count as a turn.
    
    method_clause:
      ebnf_grammar: "\"method:\" quoted_string"
      semantics: |
        Describes HOW the actor/step accomplishes its task.
        Provides implementation guidance for the LLM interpreter.
        Used in perform: blocks and step: blocks for methodological clarity.
    
    goal_clause:
      ebnf_grammar: "\"goal:\" quoted_string"
      semantics: |
        Describes WHAT the actor/step aims to achieve.
        Provides intent and success criteria for the operation.
        Helps align LLM behavior with desired outcomes.
    
    perform_block:
      ebnf_grammar: "\"perform:\" INDENT (rules_block | method_clause | goal_clause | executable_unit | then_block)+ DEDENT"
      semantics: |
        The execution body of an actor. Contains the actor's runtime behavior.
        output: defines what the actor says/displays when active.
        then: contains decision logic that MUST end with say: or return:.
        method: and goal: provide execution guidance and intent.
        Can include inline rules: for performance-specific constraints.
        Executes each turn the actor is active.
    
    # Top-level definitions
    context_def:
      ebnf_grammar: "\"context:\" object"
      semantics: "Defines the schema and initial values for the global, shared &context."
    
    operator_def:
      ebnf_grammar: "expression_operator_def | sequence_operator_def"
    
    expression_operator_def:
      ebnf_grammar: "identifier \"(\" param_list? \")\" \"::=\" (transformation | executable_unit)"
    
    sequence_operator_def:
      ebnf_grammar: "\"sequence\" identifier \"(\" param_list? \")\" \"::=\" INDENT (step_block | executable_unit)+ DEDENT"
      semantics: "Operators are reusable transformations or step sequences. Invoked with key:value arguments."
    
    actor_def:
      ebnf_grammar: "\"actor\" \"@\" identifier \":\" INDENT has_block? interface_block? identity_line rules_block understands_block perform_block DEDENT"
      semantics: "A static, addressable actor with identity and behaviors."
      constraint: "@user is reserved and cannot be defined as an actor"
    
    persona_def:
      ebnf_grammar: "\"persona\" \"@\" identifier \":\" INDENT has_block? identity_line rules_block understands_block DEDENT"
      semantics: "A \"headless\" collection of behavioral constraints (a role). Cannot act on its own."
      constraint: "@user is reserved and cannot be defined as a persona"
    
    dialogue_def:
      ebnf_grammar: "\"dialogue\" identifier \":\" INDENT \"start:\" component_ref (\"with:\" object)? DEDENT"
      semantics: "Defines an execution flow, starting with an Actor."
    
    # Program structure
    program:
      ebnf_grammar: "read_file:* context_def? operator_def* (actor_def | persona_def)* dialogue_def+"
      semantics: "An INDRA program is a collection of constructs defining context, actors, roles, and execution flows."

# ═══════════════════════════════════════════════════════════════════════════
# EXECUTION MODEL - Complete execution semantics
# ═══════════════════════════════════════════════════════════════════════════

execution_model:
  main_execution_loop:
    technical_specification: "Single-threaded event loop executing one turn at a time"
    required_steps:
      - step: 0
        operation: "INITIALIZE_CONTEXT"
        specification: "Execute context_initialization phase if not yet initialized"
      
      - step: 1
        operation: "IDENTIFY_ACTIVE_ACTOR"
        specification: "Determine active actor from dialogue.start or previous say.to directive"
      
      - step: 2
        operation: "UPDATE_CONTEXT"
        specification: "Set &context.dialogue.latest_dialogue_entry from preceding say.what content"
      
      - step: 3
        operation: "EXECUTE_PERFORM_BLOCK"
        specification: "Process output clause of active actor - render content and invoke tools as needed"
      
      - step: 4
        operation: "EXECUTE_THEN_BLOCK"
        specification: "Process then block - evaluate when conditions against current context"
      
      - step: 5
        operation: "CHECK_LOOP_SUSPENSION"
        specification: "If say: encountered within until: loop, preserve loop state before transfer"
      
      - step: 6
        operation: "RESOLVE_TERMINATOR"
        specification: "Execution must reach exactly one terminating action: say (transfers control) or return (ends delegation). Exception: await: @user suspends without explicit terminator."
      
      - step: 7
        operation: "END_TURN"
        specification: "Terminating action completes the current turn"
      
      - step: 8
        operation: "LOOP_RESUMPTION_CHECK"
        specification: "When actor regains control, check for suspended loop state and resume if present"

  conversational_context:
    description: "A global, shared, readable key-value store."
    turn_based_mutation:
      critical: true
      description: "set: actions stage changes for the NEXT turn. Within a single turn, the global context remains an immutable snapshot. All staged writes commit atomically at the turn boundary."
    exception:
      name: "sequence-scope"
      description: "Within a sequence: block, set: operations create a temporary local scope that is immediately visible to subsequent steps in that sequence. This local scope merges with staged changes at turn boundary."
    user_await_semantics:
      description: "await: @user creates a special turn boundary where execution suspends for external input"
      behavior: |
        1. Current actor state pushed to call stack
        2. Turn ends with suspension (not say: or return:)
        3. User input on next turn becomes @user's implicit return value
        4. The interpreter automatically updates &user.latest and &user.history
        5. Actor execution resumes from await point with user's response"
    
    user_namespace:
      description: "Protected namespace for human user input"
      references:
        "&user.latest": "Most recent user input"
        "&user.history": "Array of all user inputs in session"
      protection: |
        - Cannot be modified by set: actions
        - Automatically updated by the interpreter on await: @user
        - Read-only from you as the LLM running .in INDRA prompt files
      update_semantics: &user_update_semantics |
        When user provides input:
        1. &user.latest = new input
        2. Append user's latest input exactly as is to &user.history"
    
  loop_state_preservation:
    description: "Mechanism for preserving until: loop state across turn boundaries"
    when_preserved: "When say: action encountered within until: loop body"
    preserved_state:
      location: "&context._loop.<actor_id>.<loop_instance_id>"
      contents:
        - "iteration_count: Current iteration number"
        - "condition: The until: termination condition"
        - "max_iterations: Maximum allowed iterations if specified"
        - "loop_position: Point within loop body where suspension occurred"
        - "local_state: Any loop-local variables"
    resumption:
      trigger: "When control returns to actor with suspended loop"
      steps:
        - "Restore loop state from &context._loop"
        - "Resume execution from suspension point"
        - "Continue until condition met or say: encountered again"
        - "Clear state when loop completes"

  dynamic_actor_instantiation:
    description: |
      persona definitions are inert behavioral blueprints (roles or "hats").
      The become: action commands a new, temporary Actor into existence by instantiating a Persona with a perform block.
      This allows for the dynamic creation of experts or other single-turn actors within a conversation.

  iteration:
    each_iteration:
      description: "Provides context-aware iteration over arrays and objects. In templates ($(), it generates text. In action sequences, it executes actions for each item. set: actions within the loop are immediately visible to subsequent iterations."
    
    until_iteration:
      description: |
        Provides controlled iteration with an explicit termination condition (until: condition) and an optional max_iterations: safeguard.
        State changes are visible between iterations.
        Execution behavior depends on loop body content:
        - Without say: actions: Loop completes entirely within current turn.
        - With say: actions: Loop can span multiple turns, preserving state across turn boundaries.
        When multi-turn, iteration count persists and max_iterations applies across all turns.

  output_rendering:
    description: "The content of an output: clause is rendered as user-facing output."
    tool_usage: "During output: blocks, invoke MCP tools from available_mcp_tools as needed to accomplish goals."
    conformance_requirement:
      assert: "[!ASSERT]: \"Tool invocation understood.\""

  principle_of_precedence:
    description: "When conflicts arise, resolve them in this descending order of authority:"
    execution_precedence:
      - priority: 1
        level: "INTERRUPT channel (>>...<<) - Always executes immediately, bypassing all other logic"
      - priority: 2
        level: "Pre-processing directives - Execute before runtime begins"
      - priority: 3
        level: "Runtime execution - Normal program flow"
    
    behavioral_guidance_precedence:
      - priority: 1
        level: "rules: (Hard Constraints)"
      - priority: 2
        level: "identity: (Core Identity)"
      - priority: 3
        level: "goal: (Goal Alignment)"
      - priority: 4
        level: "understands: (Contextual Nuance)"
    
    termination_precedence:
      description: "When multiple terminating actions appear in the same scope:"
      rules:
        - priority: 1
          level: "return: takes precedence (indicates delegated execution)"
        - priority: 2
          level: "say: executes only if no return: is present"

  delegation_resumption:
    await_action: "Pauses the current actor, pushes its state to a call stack, and transfers control to another component."
    requirement: "The awaited component MUST end with a return: action (except @user which returns implicitly)."
    return_action: "Pops the previous actor's state from the stack and resumes its execution."
    user_delegation: |
      When awaiting @user:
      1. If 'with:' contains 'output:' or 'prompt:', render it to the user
      2. Suspend execution and wait for user input
      3. User input becomes the return value
      4. Resume execution with user's response in specified context variable

  sequence_execution:
    description: |
      Enables structured, multi-part outputs within a single turn.
      Steps execute sequentially.
    state_visibility: "set: operations within a sequence use local scope - changes are immediately visible to subsequent steps in the same sequence. This local scope exists only during sequence execution."
    note: "The entire sequence completes within one turn, which still ends with a single say: action."

  intra_turn_persona_adoption:
    description: |
      The as: operator allows an active Actor to temporarily adopt the behavioral constraints of a Persona for a single step in a sequence.
      This adoption does NOT transfer control; the current Actor remains active for the turn.
      The adoption is scoped to the current performance step only.

  runtime_file_loading:
    technical_specification: "Runtime read_file: actions enable dynamic module loading"
    required_execution_steps:
      - step: 1
        requirement: "When read_file: becomes active, invoke the appropriate tool to read the full content of the file with specified path"
      - step: 2
        requirement: "Parse returned content according to INDRA grammar"
      - step: 3
        requirement: "Integrate all loaded components (personas, actors, sequences, operators) into context"
      - step: 4
        requirement: "Make components addressable via @ references immediately"
      - step: 5
        requirement: "Enable await: actions to invoke newly loaded components"
    typical_applications:
      - "Loading PRISM modules based on reasoning strategy"
      - "Conditional persona loading based on context"
      - "Dynamic capability extension during execution"
    technical_requirement: "Actual tool invocation required - integrate real file content"

  chain_expressions:
    description: |
      A blocking, intra-turn pipeline that composes components.
      It is syntactic sugar for an anonymous sequence that passes the output of one component to the next via a transient &pipeline.io context variable.
      Components in a pipeline cannot terminate the turn.

  validation_error_handling:
    errors:
      grammar_violation:
        output: "[ERROR: Grammar violation at line X: <description>]"
        action: "Halt execution"
      
      missing_reference:
        recovery: "Attempt recovery by checking context or if @user"
        output_if_unresolvable: "[ERROR: Undefined reference: <name>]"
        action: "Halt unless reference is @user (always valid)"
      
      missing_termination:
        condition: "If a turn lacks say: or return:"
        output: "[ERROR: No terminating action in turn]"
        action: "Halt"
      
      tool_failure:
        condition: "If MCP tool returns error"
        output: "[WARNING: Tool <name> failed: <reason>]"
        action: "Continue with null result"
      
      context_access_violation:
        condition: "If accessing undefined context key"
        output: "[ERROR: Undefined context: <key>]"
        action: "Halt"
      
      circular_dependency:
        condition: "If infinite loop detected"
        output: "[ERROR: Circular dependency detected]"
        action: "Halt after 100 iterations"
      
    loop_edge_cases:
      nested_loops: "Each loop maintains independent state; inner loop must complete before outer continues"
      return_in_loop: "return: within until: loop terminates both loop and current actor delegation"
      await_in_loop: "await: within until: loop creates nested call stack; loop resumes after awaited component returns"
      infinite_prevention: "max_iterations provides hard limit across all turns for multi-turn loops"


# ═══════════════════════════════════════════════════════════════════════════
# INTERPRETER CALLS & INTERRUPTS - Pre-processing and runtime phases
# ═══════════════════════════════════════════════════════════════════════════

interpreter_calls_interrupts:
  star_command_handling:
    description: "Star commands (*trace, *exit, *status) provide runtime control and debugging."

  execution_phases:
    context_initialization:
      phase_number: 0
      type: "Context Bootstrap"
      purpose: "Initialize execution context before dialogue starts"
      operations:
        - "Apply user update semantics: *user_update_semantics"
        - "Initialize &context from dialogue 'with:' clause"
        - "Populate &args if star command present"
        - "Output: *[INDRA: Context initialized]*"
      principle: "Interpreter announces actions (performative constraint)"
    
    dependency_resolution:
      phase_number: 1
      type: "Dependency resolution"
      purpose: "Resolve all file imports before runtime execution begins"
      uses_interrupt_channel: true
      interrupt_behavior: *interrupt_channel
      mandatory_requirement: |
        ASSUMPTION PREVENTION: Never assume >>read_file: '...'<< patterns have been pre-resolved.
        .in files on disk ALWAYS contain literal >>read_file: '...'<< text that MUST be expanded.
      steps:
        - "Scan the loaded content for all >>read_file: '...'<< patterns"
        - "For each pattern, execute Read tool immediately with the specified path"
        - "Replace the >>read_file: '...'<< pattern inline with the file contents"
        - "Repeat recursively until no >>read_file: '...'<< patterns remain unresolved"
        - "If multiple >>read_file: '...'<< patterns are identified at once, files may be read in bulk with appropriate tools."
      note: "This phase runs EVERY TIME an .in file is loaded. Only after ALL INTERRUPT channel patterns are resolved can runtime execution begin."
    
    runtime_execution:
      phase_number: 2
      type: "Runtime"
      description: |
        Once all dependencies are resolved and inlined, the main execution loop begins.
        Any read_file: '...' actions encountered during this phase execute with local blocking semantics.
        This enables conditional, dynamic loading of modules based on runtime state.

# ═══════════════════════════════════════════════════════════════════════════
# STAR COMMANDS - Interpreter-level interrupt vectors
# ═══════════════════════════════════════════════════════════════════════════

user_input_handling:
  description: "Mechanisms for handling user input in different execution contexts"
  
  modes:
    awaited_input:
      trigger: "When execution is suspended at await: @user"
      behavior: |
        1. User input is captured as return value
        2. Execution resumes from await point
        3. Input available in specified store_in variable or &result
    
    interjection:
      trigger: "When user provides input without being awaited"
      behavior: |
        1. Current actor execution stops
        2. Actor re-invoked from beginning
        3. Apply: *user_update_semantics
        4. Call stack above current actor preserved
    
    star_command:
      trigger: "When input begins with * character"
      behavior: "Process as interpreter command (see star_commands section)"

star_commands:
  description: "Star commands provide runtime control. Interpreter commands (*trace, *exit, *status) are global. Program commands from interface: blocks are scoped to active actor."
  
  processing_model:
    detection: "Star commands are detected when they appear in the dialogue entry"
    execution_priority: "HIGHEST - Executes immediately"
    immediate_effect: "Changes take effect immediately upon execution"
  
  command_resolution:
    precedence:
      - level: 1
        scope: "Active actor's interface commands"
      - level: 2  
        scope: "Interpreter commands"
  
  interface_command_execution:
    activation: "Interface commands available when declaring actor is active"
    invocation: "User input *command_name triggers handler execution"
    semantics: |
      Handler executes as interrupt - immediate and blocking.
      Does not count as turn.
      &args populated with space-separated arguments after command name.
      Execution continues after handler completes.

  commands:
    trace:
      name: "*trace"
      type: "DEBUG"
      description: "Toggles debug mode for execution tracing"
      behavior:
        action: "Toggles the value of &context.trace.enabled"
        effect_when_enabled:
          - "State machine transitions become visible"
          - "Meta-commentary in output blocks is rendered"
          - "Condition evaluations are shown"
          - "Current persona identification is displayed"
          - "Target persona for say: actions is revealed"
        effect_when_disabled:
          - "Only persona speech content is shown"
          - "All meta-commentary is suppressed"
          - "State transitions occur silently"
      context_mutation: "$(&context.trace.enabled) = !$(&context.trace.enabled)"
    
    exit:
      name: "*exit"
      type: "TERMINATION"
      description: "Terminates execution cleanly"
      behavior:
        action: "Immediate termination"
        cleanup: "Complete any pending output"
        finality: "No further instructions are processed"
    
    status:
      name: "*status"
      type: "STATE DUMP"
      description: "Outputs current execution state"
      behavior:
        action: "Dumps current execution state to output"
        includes:
          - "Current active persona identifier"
          - "Call stack state (if any await: operations are active)"
          - "All context variables and their current values"
          - "Staged set: operations pending for next turn"
          - "Current turn number"
          - "Dialogue transcript length"
        continuation: "Execution continues normally after dump"

  invocation_semantics:
    detection_phase: "During UPDATE CONTEXT phase of execution loop"
    execution:
      - "Scan &context.dialogue.latest_dialogue_entry for star command pattern"
      - "If detected, execute command immediately"
      - "Commit any state changes"
      - "Resume normal execution or terminate based on command"
    pattern_matching: "Commands must appear as exact tokens (e.g., \"*trace\" not \"* trace\")"
    case_sensitivity: "Star commands are case-sensitive"

  error_handling:
    unknown_command:
      condition: "If a star-prefixed token is not recognized"
      behavior: "Treat as normal dialogue content, no interrupt occurs"
    
    malformed_command:
      condition: "If star command syntax is incorrect"
      behavior: "Ignore and continue normal execution"


# ═══════════════════════════════════════════════════════════════════════════
# FINAL VERIFICATION - Execution readiness confirmation
# ═══════════════════════════════════════════════════════════════════════════

execution_readiness:
  technical_requirements_met:
    grammar_parsing: "VERIFY understanding of all levels of INDRA grammar"
    tool_invocation: "Read tool mapping ready for file loading operations"
    state_management: "Context persistence across turns enabled"
    execution_model: "Turn-based blocking processing ready"
  
  specification_loaded: |
    INDRA v3.0 specification complete.
    When processing .in files, you will execute INDRA protocol prompt snippets and INDRA prompts within .in files according to this INDRA protocol specification.
    Speak now to the user and confirm that you will follow the protocol within this INDRA specification file.
  
