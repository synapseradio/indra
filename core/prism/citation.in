# INDRA v3.0: PRISM Module - Citation Pipeline
>>read_file: './base.in'<<

# ═══════════════════════════════════════════════════════════════════════════
# SECTION 1: CITATION SEQUENCE & OPERATORS
# ═══════════════════════════════════════════════════════════════════════════

# Reusable sequence to gather, validate, and format citations for a claim.
sequence citation_pipeline(claim) ::=
  step:
    as: self
    method: "checking search overlap"
    output: <<|
      *Analyzing if "$(claim)" requires new evidence beyond our pool...*
    |>>
    set:
      &context.citation.similarity_score: $(
        has_content(&context.citation.search_history) == 'true' ?
        $(<
          Compare "$(claim)" to &context.citation.search_history. 
          Return a score 0.0-1.0 where 1.0 means identical query, 0.0 means completely novel.
        >) : 
        0.0
      )
  step:
    as: self
    when: &context.citation.similarity_score less_than 0.7
    method: "evidence gathering via tool invocation"
    output: <<|
      *Gathering additional evidence for novel angle: "$(claim)"*
      $(<Invoke Perplexity web search tool (mcp__perplexity-mcp__perplexity_search_web) with query='$(claim)' and recency='month'. Return the actual results.>)
    |>>
    goal: "to expand evidence pool with new perspectives"
    set:
      &context.citation.raw_results: $(<Store the Perplexity search results from above>)
      &context.citation.search_history: &context.citation.search_history + [claim]
      &context.citation.search_attempted: true
  step:
    as: self
    when: &context.citation.similarity_score less_than 0.7
    method: "merging into evidence pool"
    output: <<|
      *Adding new sources to evidence pool...*
    |>>
    set:
      &context.citation.evidence_pool: $(merge_unique_evidence(
        items: &context.citation.raw_results,
        existing: &context.citation.evidence_pool
      ))
  step:
    as: self
    method: "selecting relevant evidence from pool"
    output: <<|
      *Selecting most relevant evidence from pool of $(
        has_content(&context.citation.evidence_pool) == 'true' ? 
        count(&context.citation.evidence_pool) : 
        count(&context.citation.raw_results)
      ) sources...*
    |>>
    set:
      &context.citation.filtered_results: $(
        has_content(&context.citation.evidence_pool) == 'true' ?
        select_relevant_evidence(
          pool: &context.citation.evidence_pool,
          query: claim,
          max_items: 8
        ) :
        filter_for_primary_sources(results: &context.citation.raw_results)
      )
      &context.citation.formatted: $(format_citations(results: &context.citation.filtered_results))
      &context.citation.validated: true

# Decomposed citation filtering operators for better composability

# Remove duplicate entries by URL field
deduplicate_by_url(results) ::= <
Given the results in $(results), remove all duplicate entries by the 'url' field.
Keep only the first occurrence of each unique URL.
Return the deduplicated array.
>

# Filter out low-quality sources
filter_quality_sources(results) ::= <
Given the results in $(results), filter to keep only high-quality sources.
Exclude: social media (Instagram, Twitter, TikTok), content farms, QA sites (Quora, etc.), 
and personal blogs unless widely recognized as expert sources.
Prioritize: academic journals, reputable news organizations, university websites, established publications.
Return the filtered sources.
>

# Composite operator using pipe for primary source filtering
filter_for_primary_sources(results) ::= $(
  filter_quality_sources(results: deduplicate_by_url(results: results))
)


# Validate citations have required fields before formatting
validate_citation_fields(results) ::= <
Filter $(results) to only include items that have both 'title' and 'url' fields.
Return filtered array with valid citations only.
>

# Format validated citations into markdown links
format_citation_links(results) ::= <<|
  $(each: results as |result, index| {
    <<|$(index + 1). [$(result.title)]($(result.url))|>>
  })
|>>

# Composite operator to validate then format citations
format_citations(results) ::= $(
  format_citation_links(results: validate_citation_fields(results: results))
)

# Individual assessment operators

# Count sources in collection
count_sources(results) ::= <count the sources in $(results)>

# Assess credibility of sources
assess_credibility(results) ::= <
Evaluate credibility of $(results):
- Are these primary sources?
- Recognized authors?
- Peer-reviewed?
- Reputable publications?
Return credibility assessment.
>

# Assess diversity of sources
assess_diversity(results) ::= <
Assess variety in $(results):
- Different domains represented?
- Competing viewpoints included?
- Geographic spread?
Return diversity assessment.
>

# Composite quality assessment using piped operators
assess_quality(results) ::= <<|
  Sources found: $(count_sources(results: results))
  Credibility: $(assess_credibility(results: results))
  Diversity: $(assess_diversity(results: results))
|>>

# Operator to merge evidence while maintaining uniqueness and quality
# Note: Referenced as merge_unique_evidence in the sequence
merge_unique_evidence(items, existing) ::= $(
  merge_with_existing(items: deduplicate_by_url(results: items), existing: existing)
)

# Helper to merge new items with existing collection
merge_with_existing(items, existing) ::= <
Merge $(items) into $(existing):
- Add all new items not already in existing (by URL)
- When duplicates exist, keep higher quality version
- Maintain overall diversity
Return merged array.
>

# Decomposed selection operators for citation relevance pipeline

# Filter citations by relevance to query
filter_by_relevance(pool, query) ::= <
Score each item in $(pool) by relevance to "$(query)".
Keep items with relevance score > 0.3.
Sort by relevance score descending.
Return sorted array.
>

# Ensure diversity of sources
ensure_diversity(items) ::= <
Given $(items), ensure source diversity:
- Include different domains (academic, news, technical)
- Include different perspectives where available
- Avoid over-representation from single sources
Return diverse selection maintaining order.
>

# Limit to maximum number of items
limit_items(items, max) ::= <
Take the first $(max) items from $(items).
Return limited array.
>

# Composite operator for selecting relevant citations
select_relevant_evidence(pool, query, max_items) ::= $(
  limit_items(items: ensure_diversity(items: filter_by_relevance(pool: pool, query: query)), max: max_items)
)
