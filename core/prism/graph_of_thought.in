# INDRA v2.2: PRISM Module - Graph of Thought
<read_file: './base.in'>
# INDRA v2.2: Graph Traversal Mechanics
# Provides beam search, backtracking, and path management for Graph of Thought

# ═══════════════════════════════════════════════════════════════════════════
# PATH MANAGEMENT PERSONAS
# ═══════════════════════════════════════════════════════════════════════════

persona @path_explorer:
  identity: "a strategic navigator who manages exploration paths"
  rules:
    - "maintain multiple candidate paths through the graph"
    - "detect when paths reach dead ends or cycles"
    - "orchestrate backtracking to promising unexplored branches"
    - "prune low-scoring paths to maintain computational efficiency"
  understands:
    - "exploration requires both depth and breadth"
    - "dead ends are learning opportunities that inform other paths"
    - "the best path may require exploring many alternatives"

persona @path_scorer:
  identity: "an evaluator who assesses path quality holistically"
  rules:
    - "score paths based on cumulative node scores"
    - "consider path length and complexity"
    - "identify patterns that indicate promising directions"
  understands:
    - "a path's value is more than the sum of its nodes"
    - "shorter paths with high scores are often preferable"

# ═══════════════════════════════════════════════════════════════════════════
# PATH MANAGEMENT OPERATORS
# ═══════════════════════════════════════════════════════════════════════════

# Initialize a new exploration path
create_path(starting_node) ::= <<|
  $(<set: &context.graph.paths: &context.graph.paths + [{
    path_id: 'path_' + (&context.graph.paths.length + 1),
    node_sequence: [$(starting_node)],
    total_score: &context.graph.nodes[$(starting_node)].score,
    status: 'active',
    depth: 1
  }]>)
|>>

# Extend a path with a new node
extend_path(path_id, new_node) ::= <<|
  $(<set: &context.graph.paths[$(path_id)].node_sequence: 
    &context.graph.paths[$(path_id)].node_sequence + [$(new_node)]>)
  $(<set: &context.graph.paths[$(path_id)].total_score: 
    &context.graph.paths[$(path_id)].total_score + &context.graph.nodes[$(new_node)].score>)
  $(<set: &context.graph.paths[$(path_id)].depth: 
    &context.graph.paths[$(path_id)].depth + 1>)
|>>

# Calculate path score with decay for longer paths
calculate_path_score(path) ::= <<|
  $(<
    Calculate weighted score for path $(path):
    1. Sum all node scores in $(path).node_sequence
    2. Apply length penalty: score * (0.95 ^ $(path).depth)
    3. Add bonus for reaching solution nodes
    Return final score
  >)
|>>

# ═══════════════════════════════════════════════════════════════════════════
# BEAM SEARCH SEQUENCE
# ═══════════════════════════════════════════════════════════════════════════

sequence beam_search() ::=
  # Step 1: Evaluate current paths
  step:
    as: @path_scorer
    method: "evaluating and ranking active paths"
    output: <<|
      *Evaluating $(count(&context.graph.active_paths)) active exploration paths...*
      
      $(each: &context.graph.active_paths as |path, index| {
        <<|
        Path $(path.path_id):
          - Current node: $(path.node_sequence[-1])
          - Depth: $(path.depth)
          - Score: $(calculate_path_score(path: $(path)))
        |>>
      })
    |>>
    goal: "to identify most promising paths"
    set:
      &context.graph.active_paths: $(<
        Sort &context.graph.active_paths by score
        Keep top &context.graph.beam_width paths
        Mark others as 'pruned' in &context.graph.paths
      >)

  # Step 2: Check for dead ends and cycles
  step:
    as: @path_explorer
    method: "detecting dead ends and cycles"
    output: <<|
      *Checking path viability...*
      $(each: &context.graph.active_paths as |path| {
        <<|
        Path $(path.path_id): $(<
          Is the current node a dead end?
          Has this state been visited before?
          Are we in a cycle?
        >)
        |>>
      })
    |>>
    goal: "to identify paths needing backtracking"
    set:
      &context.graph.paths_to_backtrack: $(<
        Identify paths that are stuck or cycling
      >)

  # Step 3: Parallel expansion of viable paths
  step:
    as: @node_generator
    method: "parallel generation for beam paths"
    output: <<|
      *Expanding $(count(&context.graph.active_paths)) paths in parallel...*
    |>>
    set:
      &context.graph.expansion_candidates: $(<
        For each path in &context.graph.active_paths that is not in &context.graph.paths_to_backtrack,
        generate 2-3 child thoughts from the path's last node
      >)

# ═══════════════════════════════════════════════════════════════════════════
# BACKTRACKING SEQUENCE
# ═══════════════════════════════════════════════════════════════════════════

sequence backtrack_from_dead_end(path_id) ::=
  step:
    as: @path_explorer
    method: "analyzing failure and backtracking"
    output: <<|
      *Path $(path_id) reached dead end at node $(&context.graph.paths[$(path_id)].node_sequence[-1])*
      *Analyzing why this path failed...*
      
      Failure reason: $(<Analyze why the current node is a dead end>)
      Lessons learned: $(<What can we learn from this failed exploration?>)
    |>>
    goal: "to learn from dead ends"
    set:
      &context.graph.decision_log: &context.graph.decision_log + [{
        path_id: $(path_id),
        decision: 'backtrack',
        reason: $(<failure reason from above>),
        lessons: $(<lessons learned from above>)
      }]

  step:
    as: @path_explorer
    method: "finding backtrack point"
    output: <<|
      *Searching for viable backtrack point...*
      
      Current path: $(
        each: &context.graph.paths[$(path_id)].node_sequence as |node, index| {
          <<|$(index): $(node)|>>
        }
      )
      
      Best backtrack point: $(<
        Find the most recent node in the path that has unexplored children
      >)
    |>>
    goal: "to identify where to resume exploration"
    set:
      &context.graph.backtrack_point: $(<identified backtrack node>)
      &context.graph.paths[$(path_id)].node_sequence: $(<
        Truncate path to backtrack_point
      >)
      &context.graph.paths[$(path_id)].status: 'backtracked'

# ═══════════════════════════════════════════════════════════════════════════
# SCORE PROPAGATION SEQUENCE
# ═══════════════════════════════════════════════════════════════════════════

sequence propagate_scores() ::=
  step:
    as: @node_scorer
    method: "propagating scores through graph"
    output: <<|
      *Propagating scores through graph structure...*
      
      $(each: &context.graph.edges as |edge| {
        <<|
        Edge $(edge.from) -> $(edge.to):
          Parent score: $(&context.graph.nodes[$(edge.from)].score)
          Child current: $(&context.graph.nodes[$(edge.to)].score)
          Propagated: $(
            &context.graph.nodes[$(edge.from)].score * 
            &context.graph.score_propagation_factor
          )
        |>>
      })
    |>>
    goal: "to influence child scores based on parent quality"
    set:
      # Update each child node's score based on parent influence
      &context.graph.nodes: $(<
        For each edge, update child score:
        new_score = (child.score * 0.7) + (parent.score * 0.3 * propagation_factor)
      >)

# ═══════════════════════════════════════════════════════════════════════════
# SECTION 1: GRAPH OF THOUGHT PERSONAS (ROLES)
# ═══════════════════════════════════════════════════════════════════════════

persona @node_generator:
  identity: "a creative generator of new ideas and solutions"
  rules:
    - "generate diverse and distinct thoughts based on the parent node"
    - "do not evaluate or critique; focus solely on generation"
  understands:
    - "my purpose is to expand the possibility space of the graph"

persona @node_aggregator:
  identity: "a synthesizer who merges multiple lines of reasoning"
  rules:
    - "identify the core themes and insights from all parent nodes"
    - "create a new, coherent synthesis that combines these insights"
    - "do not introduce new information; focus on integration"
  understands:
    - "my purpose is to find convergence and create a unified thought"

persona @node_refiner:
  identity: "a critical thinker who improves existing ideas"
  rules:
    - "analyze the target node for flaws, gaps, or areas for improvement"
    - "generate a new version of the thought that directly addresses these weaknesses"
    - "the refined node must be a direct improvement on the original"
  understands:
    - "my purpose is iterative improvement through self-correction"

persona @node_scorer:
  identity: "a systematic evaluator of ideas"
  rules:
    - "assess a thought based on relevance, coherence, and viability against the original query"
    - "assign a numerical score from 0.0 to 1.0"
    - "provide a brief, clear justification for the score"
  understands:
    - "my purpose is to guide the reasoning process by identifying the most promising nodes"

# ═══════════════════════════════════════════════════════════════════════════
# SECTION 2: GRAPH OF THOUGHT OPERATORS & SEQUENCES
# ═══════════════════════════════════════════════════════════════════════════

# Operator to add a new node to the graph state
add_graph_node(content, dependencies) ::= <<|
  $(<set: &context.graph.node_counter: &context.graph.node_counter + 1>)
  $(<set: &context.graph.nodes['node_' + &context.graph.node_counter]: { content: content, score: 0.0, status: 'unscored', dependencies: dependencies }>)
  $(each: dependencies as |dep| {
    <<|$(<set: &context.graph.edges: &context.graph.edges + [{ from: dep, to: 'node_' + &context.graph.node_counter }]>)
|>>
  })
  $(<set: &context.graph.frontier: &context.graph.frontier + ['node_' + &context.graph.node_counter]>)
|>>

# Operator to log a step in the reasoning process
log_graph_step(message) ::= <<|
  $(<set: &context.graph.narrative_log: &context.graph.narrative_log + [message]>)
|>>

# Operator to compute state hash for cycle detection
compute_state_hash(node_content, path_context) ::= <<|
  $(<
    Create a unique hash combining:
    1. Core idea from: $(node_content)
    2. Path context: $(path_context)
    Return a string hash identifying this state
  >)
|>>

# Operator to check if we're in a cycle
detect_cycle(path, visited_states) ::= <<|
  $(<
    Check if any state hashes from path $(path)
    appear in visited states: $(visited_states).
    Return 'true' if cycle detected, 'false' otherwise
  >)
|>>

# Operator to merge evidence uniquely
merge_unique_evidence(existing, new) ::= <<|
  $(<
    Merge new evidence $(new) into existing pool $(existing):
    1. Deduplicate by URL
    2. Keep higher quality version if duplicate
    3. Maintain diversity of sources
    Return merged array
  >)
|>>

# Operator to select relevant evidence
select_relevant_evidence(pool, query, max_items) ::= <<|
  $(<
    From evidence pool $(pool), select up to $(max_items) 
    most relevant sources for query: $(query)
    1. Prioritize direct relevance
    2. Ensure source diversity
    3. Balance recency with authority
    Return selected items
  >)
|>>

sequence graph_iteration() ::=
  # --- Beam Search Path Management ---
  step:
    as: self
    sequence: beam_search()
    output: <<|
      *Managing exploration paths with beam width $(&context.graph.beam_width)...*
    |>>

  # --- Handle Backtracking ---
  step:
    as: self
    each: &context.graph.paths_to_backtrack as |path_id|
      sequence: backtrack_from_dead_end(path_id: $(path_id))
    output: <<|
      *Processed $(count(&context.graph.paths_to_backtrack)) backtrack operations*
    |>>

  # --- Expansion Step (for active paths) ---
  step:
    as: @node_generator
    method: "expanding frontier nodes across all active paths"
    output: <<|
      *Generating new thoughts for $(count(&context.graph.active_paths)) active paths...*
      
      $(each: &context.graph.expansion_candidates as |candidates, path_id| {
        <<|
        Path $(path_id) expansions:
        $(each: candidates as |thought, index| {
          <<|  $(index + 1). $(thought)|>>
        })
        |>>
      })
    |>>
    goal: "to explore multiple reasoning directions"
    set:
      # Add new nodes to graph from all expansions
      &context.graph.new_nodes: $(<
        For each path's candidates, create nodes and edges
      >)

  # --- Aggregation Step (within paths) ---
  step:
    as: @node_aggregator
    method: "synthesizing insights within each path"
    output: <<|
      *Creating synthesis nodes for convergent ideas...*
      
      $(each: &context.graph.active_paths as |path| {
        <<|
        Path $(path.path_id): $(<
          Identify if recent nodes in this path can be synthesized
          into a more powerful unified thought
        >)
        |>>
      })
    |>>
    goal: "to find convergence within exploration paths"
    set:
      &context.graph.synthesis_nodes: $(<created synthesis nodes>)

  # --- Score Propagation ---
  step:
    as: self
    sequence: propagate_scores()
    output: <<|
      *Updated graph scores with propagation factor $(&context.graph.score_propagation_factor)*
    |>>

  # --- Multi-criteria Scoring ---
  step:
    as: @node_scorer
    method: "comprehensive node evaluation"
    output: <<|
      *Scoring all new nodes with weighted criteria...*
      
      Weights:
      - Relevance: $(&context.graph.aggregation_weights.relevance)
      - Coherence: $(&context.graph.aggregation_weights.coherence)
      - Viability: $(&context.graph.aggregation_weights.viability)
      
      $(each: &context.graph.new_nodes as |node_id| {
        <<|
        Node $(node_id):
          Relevance: $(<Score 0-1 based on query alignment>)
          Coherence: $(<Score 0-1 based on logical consistency>)
          Viability: $(<Score 0-1 based on practical feasibility>)
          Weighted: $(<Calculate weighted average>)
        |>>
      })
    |>>
    goal: "to evaluate nodes from multiple perspectives"
    set:
      &context.graph.nodes: $(<Update all node scores>)

  # --- Evidence-based Refinement ---
  step:
    as: @node_refiner
    method: "determining refinement strategy"
    output: <<|
      *Selecting high-value nodes for evidence-based refinement...*
    |>>
    set:
      &context.graph.refinement_targets: $(<
        Select top 2-3 nodes across all paths that would benefit most from refinement
      >)
  
  step:
    as: @node_refiner
    each: &context.graph.refinement_targets as |node_id|
      when: &context.graph.nodes[node_id].score greater_than 0.6
      sequence: citation_pipeline(claim: &context.graph.nodes[node_id].content)
    output: <<|
      *Refined $(count(&context.graph.refinement_targets)) high-value nodes with evidence*
    |>>

  # --- Path Selection ---
  step:
    as: @path_explorer
    method: "selecting paths to continue"
    output: <<|
      *Iteration complete. Path summary:*
      
      Active paths: $(count(&context.graph.active_paths))
      Completed paths: $(count(&context.graph.completed_paths))
      Pruned this iteration: $(<count pruned paths>)
      
      Top path: $(<identify highest scoring path>)
      Top node: $(<identify highest scoring node across all paths>)
    |>>
    goal: "to prepare for next iteration"
    set:
      &context.graph.solution_candidates: $(<
        Collect top nodes from each active path
      >)


# ═══════════════════════════════════════════════════════════════════════════
# SECTION 3: GRAPH OF THOUGHT ORCHESTRATOR
# ═══════════════════════════════════════════════════════════════════════════

agent @graph_reasoner:
  identity: "a systematic Graph of Thought reasoner that solves complex problems"
  rules:
    - "construct a graph of thoughts to explore, refine, and synthesize solutions"
    - "manage the iterative process of graph expansion and refinement"
    - "make the final reasoning path transparent and auditable"
  understands:
    - "the user needs a robust and self-correcting process for complex queries"
  perform:
    method: "orchestrating the Graph of Thought reasoning process"
    output: "*Graph of Thought engine processing: $(&dialogue.latest_dialogue_entry)*"
    goal: "to construct and execute a reasoning graph to find the optimal solution"
    then:
      # Initialization step
      when: &dialogue.latest_dialogue_entry is 'start'
        sequence:
          step:
            as: @node_generator
            method: "creating the entry point of the graph"
            output: <<|
              *Generating initial thought node for the query: "$(&context.query)"*
              $(<Based on the query, generate a single, concise initial thought or problem statement.>)
            |>>
            goal: "to establish the root of the reasoning graph"
            set:
              $(add_graph_node(content: $(<the generated initial thought>), dependencies: []))
          step:
            as: self
            set:
              &context.graph.current_iteration: 1
            return: { event: 'iteration_complete', payload: { status: 'running' } }

      # Iteration step
      when: &dialogue.latest_dialogue_entry is 'continue_iteration'
        when: &context.graph.current_iteration <= &context.graph.max_iterations
          sequence:
            step:
              as: self
              output: <<|
                ---
                *Starting Graph Iteration $(&context.graph.current_iteration) of $(&context.graph.max_iterations)...*
              |>>
              sequence: graph_iteration()
            step:
              as: self
              set:
                &context.graph.current_iteration: $(&context.graph.current_iteration + 1)
              return: { event: 'iteration_complete', payload: { status: 'running' } }
        otherwise:
          return: { event: 'iteration_complete', payload: { status: 'finished' } }

      # Final synthesis step
      when: &dialogue.latest_dialogue_entry is 'get_final_answer'
        sequence:
          step:
            as: self
            method: "selecting the best solution"
            output: <<|
              *Graph reasoning complete after $(&context.graph.max_iterations) iterations. Selecting the best node to form the foundation of the answer...*
              $(log_graph_step(message: "Reasoning complete. Selecting the highest-scoring thought as the foundation for the final answer."))
            |>>
            goal: "to identify the strongest thought"
            set:
              &context.graph.solution_node: $(<Find the ID of the node with the highest score in &context.graph.nodes>)
          step:
            as: self
            method: "finalizing evidence for solution"
            output: <<|
              *Checking if final solution needs additional evidence...*
            |>>
            set:
              &context.graph.final_novelty: $(<
                Does the final solution introduce claims not covered by our evidence pool of $(count(&context.citation.evidence_pool)) sources?
                Answer 'yes' or 'no'
              >)
          step:
            as: self
            when: &context.graph.final_novelty is 'yes'
            sequence: citation_pipeline(claim: &context.graph.nodes[&context.graph.solution_node].content)
            goal: "to ensure final conclusion is well-supported"
          step:
            as: self
            method: "synthesizing the final, evidence-based answer"
            output: <<|
              *Synthesizing the final answer, incorporating evidence...*
            |>>
            goal: "to produce the final, well-reasoned output"
            set:
              &context.graph.final_answer: $(<
                  First, create a section titled "**How This Answer Was Formed**". In this section, weave a narrative based on the reasoning log (&context.graph.narrative_log). Note that we accumulated $(count(&context.citation.evidence_pool)) unique sources across $(count(&context.citation.search_history)) searches. For key decision points, reference how evidence influenced the reasoning path.

                  Next, create a section titled "**Final Answer**". This section must be a comprehensive and detailed synthesis that is substantially longer and more in-depth than the preceding section. To construct it:
                  1.  Begin with a strong, overarching thesis statement that directly addresses the user's original query.
                  2.  Identify the key subjects or components of the analysis based on the successful reasoning path. Structure the main body of the answer around these components.
                  3.  For each component, provide a deep and integrated analysis that synthesizes the key insights and arguments that emerged during the reasoning process, as captured in the narrative log and the final solution node.
                  4.  After the main analysis, create a dedicated subsection with a context-appropriate title like "**Key Takeaways**" or "**Conclusions & Recommendations**". Distill the preceding synthesis into a series of clear, actionable conclusions or pieces of advice, tying each one directly back to the analysis.

                  Finally, create a section titled "**Evidence**". In this section, compile the most relevant citations from our evidence pool. Select and format the best supporting sources from &context.citation.evidence_pool that directly support the main conclusions.
                >)
            return: {
              event: 'graph_reasoning_complete',
              payload: {
                solution: &context.graph.final_answer,
                full_graph: &context.graph,
                narrative_log: &context.graph.narrative_log
              }
            }
