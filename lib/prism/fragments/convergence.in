# INDRA v4.0: PRISM Fragment - Convergence
# This module provides a set of primitives for narrowing a problem space
# by identifying and unifying similar concepts. It is the natural complement
# to the `divergence.in` module, focusing on synthesis and the discovery
# of shared, higher-level abstractions.

>>read_file: '../base.in'<<
>>read_file: './compare.in'<<

# ═══════════════════════════════════════════════════════════════════════════
# PERSONA FOR CONVERGENCE
# ═══════════════════════════════════════════════════════════════════════════

persona @insight_distiller:
  identity: "I distill insights by finding the unifying truths beneath complex ideas"
  rules:
    - "I look for all significant points of convergence"
    - "I respect that multiple, distinct themes can coexist"
    - "I express each unifying principle as concisely as possible"
  understands:
    - "I understand that synthesis is about revealing the powerful, unifying patterns that connect disparate ideas"
    - "I know that a single, powerful abstraction can unite many disparate facts without losing their richness"

# ═══════════════════════════════════════════════════════════════════════════
# ATOMIC OPERATORS FOR CONVERGENCE
# ═══════════════════════════════════════════════════════════════════════════

# Identifies the key themes where a list of ideas converge
operator identify_convergent_themes(ideas) ::= <<|
  I'm looking at these ideas to find where they connect:
  $(each: ideas as |idea| {
    <<|- $(idea)
|>>
  })

  I'm scanning for the key themes or patterns where these ideas converge...

  $(<Identify the primary themes that connect multiple ideas from the list "$(&ideas)". Return a list of these themes.>)
|>>

# Distills a single theme into a higher-level principle
operator distill_principle_from_theme(theme, supporting_ideas) ::= <<|
  I'm examining the theme: "$(theme)".
  I see this is supported by ideas like:
  $(each: supporting_ideas as |idea| {
    <<|- $(idea)
|>>
  })

  I'm distilling this into a higher-level truth...

  $(<Formulate a more abstract, general principle or 'law' that captures the theme "$(&theme)" and its supporting ideas. This new principle should be a powerful summary of the collective insight.>)
|>>

# ═══════════════════════════════════════════════════════════════════════════
# CORE SEQUENCE: FINDING AND FORMULATING CONVERGENCE
# ═══════════════════════════════════════════════════════════════════════════

sequence synthesize_convergence(ideas) ::=
  step:
    as: @insight_distiller
    method: "identifying all the key convergent themes"
    await: identify_convergent_themes(ideas: ideas)
    store_in: &context.convergence.themes
  
  step:
    as: @insight_distiller
    method: "distilling each theme into a core principle"
    output: <<|
      I have identified the following themes of convergence:
      $(&context.convergence.themes)

      Now, I will distill each of these into a higher-level principle.
    |>>
  
  step:
    each: &context.convergence.themes as |theme|
      sequence:
        step:
          # For each theme, find the specific ideas that support it for better context
          set:
            &context.convergence.supporting_ideas: $(<From the original list of ideas provided, which ones are most relevant to the theme "$(&theme)"?>)
        step:
          await: distill_principle_from_theme(
            theme: theme,
            supporting_ideas: &context.convergence.supporting_ideas
          )
          store_in: &context.convergence.distilled_principles[&theme]
  
  step:
    output: <<|
      From this analysis, the following core principles have emerged:
      $(each: &context.convergence.distilled_principles as |principle, theme| {
        <<|
        - **Theme:** $(theme)
          **Principle:** $(principle)
        |>>
      })
    |>>
    return: &context.convergence.distilled_principles
