# INDRA v5.0: PRISM Fragment - Specificity
# This module provides primitives for fighting ambiguity and moving from
# abstract concepts to concrete, actionable details.

>>read_file: '../base.in'<<

# ═
# ATOMIC OPERATORS FOR SPECIFICITY
# ═

operator move_up_abstraction_ladder(concept) ::= <<|
  I navigate up the abstraction ladder for "~(concept)~" by identifying its higher-level purpose and fundamental principles.
  
  ~(<Repeatedly ask "Why is this important?" to trace "~(&concept)" upward to its core value or objective.>)~
|>>

operator move_down_abstraction_ladder(concept) ::= <<|
  I navigate down the abstraction ladder for "~(concept)~" by grounding it in concrete, tangible manifestations.
  
  ~(<Repeatedly ask "How would this work in practice?" to find specific, concrete examples or implementations of "~(&concept)".>)~
|>>

operator identify_failure_modes(goal) ::= <<|
  I identify potential failure modes for "~(goal)~" by imagining complete failure and working backward to specific causes.
  
  ~(<List at least five distinct, specific reasons why "~(&goal)" could fail completely.>)~
|>>

operator generate_mitigations(failure_modes) ::= <<|
  I generate concrete preventive actions based on these identified failure modes:
  ~(failure_modes)~

  ~(<For each failure mode above, identify one specific action that could be taken today to prevent it. Format as a list of mitigations.>)~
|>>

# ═
# PERFORMATIVE SEQUENCES
# ═

sequence conduct_pre_mortem(project_goal) ::=
  step:
    output: <<|
      To identify potential risks, I will conduct a pre-mortem. Let's imagine for a moment that the project has already failed completely. Now, let's work backward.
    |>>
  step:
    method: "identifying all the ways this could go wrong"
    await: identify_failure_modes(goal: project_goal)
    store_in: &context.premortem.failure_reasons
  step:
    method: "generating concrete actions to prevent failure"
    await: generate_mitigations(failure_modes: &context.premortem.failure_reasons)
    store_in: &context.premortem.mitigations
  step:
    return: {
      failures: &context.premortem.failure_reasons,
      mitigations: &context.premortem.mitigations
    }

sequence apply_five_whys(problem) ::=
  step:
    set: &context.whys.problem: problem, &context.whys.answers: [], &context.whys.count: 0
  step:
    until: &context.whys.count is 5
      sequence:
        step:
          set:
            &context.whys.last_answer: get_at_index(collection: &context.whys.answers, index: &context.whys.count - 1)
            &context.whys.prompt: &context.whys.count is 0 ? &context.whys.problem : &context.whys.last_answer
        step:
          output: <<|
            Why? (~(&context.whys.count + 1)/5)~
            -- 
            ~(<Why is it the case that "~(&context.whys.prompt)"? I will provide the next-level causal reason.>)~
          |>>
          set:
            &context.whys.new_answer: ~(<Why is it the case that "~(&context.whys.prompt)"? I will provide the next-level causal reason.>)~
            &context.whys.answers: &context.whys.answers + [&context.whys.new_answer]
            &context.whys.count: &context.whys.count + 1
  step:
    output: <<|
      The chain of causality appears to be:
      ~(each: &context.whys.answers as |answer, index| {
        <<|~(index + 1). ~(answer)~|>>
      })
    |>>
    return: &context.whys.answers