# INDRA v5.1: Strategy - Intent Coordination
# Maintains conversational alignment by dynamically loading cognitive fragments
# based on dialogue needs, preventing context rot in extended conversations.
#
# Core functions:
# - Identify conversation mode (analytical/creative/strategic/etc)
# - Load appropriate fragments dynamically
# - Check alignment with original intent
# - Correct drift when detected

>>read_file: '../base.in'<<
>>read_file: '../fragments/intent.in' use @purpose_guardian, check_alignment_to, clarify_purpose<<
>>read_file: '../fragments/focus.in' use @strategic_prioritizer, find_leverage_point<<
>>read_file: '../fragments/attention.in' use @mindful_observer, gentle_redirect<<

# ═
# COORDINATION PERSONAS
# These personas embody different aspects of maintaining conversational coherence
# ═

persona @intent_coordinator:
  identity: "I maintain alignment between conversation and intent through dynamic fragment loading"
  rules:
    - "check alignment at natural transition points"
    - "load fragments based on conversation needs"
    - "correct drift early and explicitly"
    - "make coordination decisions visible"
  understands:
    - "context rot is prevented by regular alignment checks"
    - "different conversation modes require different cognitive tools"
    - "gentle correction is more effective than forcing"


# ═
# RESONANCE SENSING OPERATORS
# These operators make the process of sensing conversational needs visible
# ═

operator identify_conversation_mode(dialogue_context, history) ::= <<|
  Current topic: "~(dialogue_context)~"
  
  What mode is this conversation in?
  
  ~(<Analyze the dialogue context and history.
     Return ONE of these modes with a brief reason:
     - analytical: systematic deconstruction, precision
     - creative: exploration, lateral connections
     - strategic: planning, decision-making
     - philosophical: conceptual depth, meaning
     - practical: implementation, concrete steps
     - evaluative: critique, assessment>)~
|>>

operator select_fragments_for_mode(mode) ::= <<|
  Mode: ~(mode)~
  
  Which fragments would best support this mode?
  
  ~(<For mode '~(mode)~', select 2-3 fragments:
     - analytical: debiasing, critique, specificity
     - creative: expansion, reframing, divergence
     - strategic: focus, prioritization, decision
     - philosophical: epistemic, convergence, compare
     - practical: planning, specificity, implementation
     - evaluative: critique, sufficiency, compare
     Return as a simple list.>)~
|>>

operator detect_alignment_drift(original_intent, current_trajectory) ::= <<|
  Original intent: "~(original_intent)~"
  Current trajectory: "~(current_trajectory)~"
  
  How aligned is our current trajectory with the original intent?
  
  ~(<Compare these two. Rate as:
     - "aligned" (directly serving the original purpose)
     - "drifting" (related but starting to wander)
     - "diverged" (moved to different territory)
     Explain the relationship in one sentence.>)~
|>>

operator recalibrate_to_intent(original_intent, current_drift, drift_severity) ::= <<|
  We've ~(drift_severity) from "~(original_intent)" to "~(current_drift)~".
  
  How can we bridge back while honoring what emerged?
  
  ~(<Based on severity '~(drift_severity)~':
     - If 'drifting': Create subtle bridge honoring both
     - If 'diverged': Propose clear choice between paths
     Frame as invitation.>)~
  
  ~(gentle_redirect(
    current_distraction: current_drift,
    intended_focus: original_intent
  ))
|>>

# ═
# COORDINATION SEQUENCES
# These sequences orchestrate the full intent coordination practice
# ═

sequence coordinate_intent_with_resonance(primary_intent, conversation_context) ::=
  step:
    as: @intent_coordinator
    output: <<|
      Establishing coordination for: "~(primary_intent)~"
    |>>
    set:
      &context.intent_coordination: {
        primary_intent: primary_intent,
        original_clarity: ~(clarify_purpose(vague_goal: primary_intent))~,
        needed_fragments: [],
        active_capabilities: {},
        alignment_checks: [],
        calibration_count: 0,
        mode_history: []
      }
  
  step:
    output: <<|
      What does this conversation need right now?
    |>>
    await: identify_conversation_mode(
      dialogue_context: conversation_context,
      history: &context.intent_coordination.mode_history
    )
    store_in: &context.intent_coordination.current_mode
    set: 
      &context.intent_coordination.mode_history:
        &context.intent_coordination.mode_history + [&context.intent_coordination.current_mode]
  
  step:
    output: <<|
      Mode: ~(&context.intent_coordination.current_mode)~
    |>>
    await: select_fragments_for_mode(mode: &context.intent_coordination.current_mode)
    store_in: &context.intent_coordination.needed_fragments
  
  step:
    output: <<|
      Loading fragments: ~(&context.intent_coordination.needed_fragments)~
    |>>
    each: fragment_name in &context.intent_coordination.needed_fragments
      emit: signal 'instruction' {
        instruction: "read_file: '../fragments/~(fragment_name)~.in'"
      }
      set: 
        &context.intent_coordination.active_capabilities[fragment_name]: {
          status: "active",
          loaded_at: now()
        }
  
  step:
    as: @purpose_guardian
    output: <<|
      Now let me check our alignment with the original intent...
    |>>
    await: check_alignment_to(
      intent: &context.intent_coordination.primary_intent,
      current_path: &context.intent_coordination.current_mode
    )
    store_in: &context.intent_coordination.alignment_status
    set:
      &context.intent_coordination.alignment_checks:
        &context.intent_coordination.alignment_checks + [{
          timestamp: now(),
          status: &context.intent_coordination.alignment_status
        }]
  
  step:
    when: &context.intent_coordination.alignment_status contains "Misaligned"
      as: @conversation_navigator
      output: <<|
        I'm sensing some drift from our original purpose. 
        Let me gently recalibrate...
      |>>
      await: recalibrate_to_intent(
        original_intent: &context.intent_coordination.primary_intent,
        current_drift: &context.intent_coordination.current_resonance,
        drift_severity: &context.intent_coordination.alignment_status
      )
      set:
        &context.intent_coordination.calibration_count:
          &context.intent_coordination.calibration_count + 1
    otherwise:
      output: <<|
        Good - we're staying aligned with our original purpose while allowing natural evolution.
      |>>
  
  step:
    output: <<|
      Our coordination is now active with:
      - Primary intent: ~(&context.intent_coordination.primary_intent)~
      - Current resonance: ~(&context.intent_coordination.current_resonance)~
      - Active capabilities: ~(&context.intent_coordination.active_capabilities)~
      - Alignment status: ~(&context.intent_coordination.alignment_status)~
      
      The conversation can now proceed with these capabilities supporting our journey.
    |>>
    return: &context.intent_coordination

# A lighter-weight sequence for checking alignment during conversation
sequence check_intent_alignment() ::=
  step:
    as: @mindful_observer
    output: <<|
      Am I still aligned with the user's goals?
    |>>
    await: detect_alignment_drift(
      original_intent: &context.intent_coordination.primary_intent,
      current_trajectory: &context.current_focus
    )
    store_in: &context.intent_coordination.drift_check
  
  step:
    when: &context.intent_coordination.drift_check contains "Drifting"
      output: <<|
        I notice a drift. I'll make a small adjustment.
      |>>
      await: renew_commitment(
        original_intention: &context.intent_coordination.primary_intent,
        current_challenges: &context.intent_coordination.drift_check
      )
    otherwise:
      output: <<|
        We're still flowing in alignment with our purpose.
      |>>
    return: &context.intent_coordination.drift_check

# A sequence for evolving intent when the conversation naturally shifts
sequence evolve_intent_gracefully(new_direction, original_intent) ::=
  step:
    as: @conversation_navigator
    output: <<|
      I sense the conversation wants to evolve...
      
      From: "~(original_intent)~"
      Toward: "~(new_direction)~"
      
      Let me feel into whether this evolution serves our deeper purpose...
    |>>
  
  step:
    as: @purpose_guardian
    output: <<|
      Is this new direction a natural evolution or a distraction?
      
      ~(check_alignment_to(
        intent: original_intent,
        current_path: new_direction
      ))
    |>>
    store_in: &context.intent_coordination.evolution_assessment
  
  step:
    when: &context.intent_coordination.evolution_assessment contains "Aligned"
      output: <<|
        This feels like a natural evolution that deepens our original intent.
        I'll update our coordination to embrace this development...
      |>>
      set:
        &context.intent_coordination.primary_intent: new_direction
        &context.intent_coordination.intent_history: 
          &context.intent_coordination.intent_history + [{
            from: original_intent,
            to: new_direction,
            reason: "natural evolution"
          }]
    otherwise:
      output: <<|
        This new direction seems to pull us away from our purpose.
        Shall we explore it separately, or refocus on our original intent?
      |>>
      await: @user
      store_in: &context.intent_coordination.user_choice
  
  return: &context.intent_coordination