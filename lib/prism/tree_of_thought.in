# INDRA v5.1: PRISM Module - Tree of Thought
# This module provides components for a structured, hierarchical exploration
# of a topic. It follows a branching path of reasoning, allowing for deep
# dives into specific sub-problems while maintaining a clear logical structure.

# A natural, modular approach to exploratory thinking
>>read_file: './base.in'<<
>>read_file: './thinking_primitives.in'<<
>>read_file: './citation.in'<<
>>read_file: './fragments/dialogue_navigation.in'<<

# ═
# ORCHESTRATION SEQUENCE - The Main Entry Point
# ═

sequence tree_of_thought(question, exploration_style, max_depth) ::=
  step:
    await: initialize_tree(question: question, exploration_style: exploration_style, max_depth: max_depth)
  step:
    await: branch_and_explore(current_focus: &context.tree.current_focus)
  step:
    await: deepen_and_validate(thought: &context.tree.current_focus, max_depth: max_depth)
  step:
    await: synthesize_findings(thoughts: &context.tree.thoughts_so_far)
  step:
    return: &context.tree.final_result

# ═
# SUB-SEQUENCES - The Core Logic Steps
# ═

sequence initialize_tree(question, exploration_style, max_depth) ::=
  step:
    as: self
    method: "beginning exploration"
    output: <<|
      I'm thinking through this with ~(exploration_style)~...
      
      The question is: ~(question)~
    |>>
    set:
      &context.tree.original_question: question
      &context.tree.exploration_style: exploration_style
      &context.tree.thoughts_so_far: []
      &context.tree.current_depth: 0
      &context.tree.journey: ['Started wondering about the question']
  step:
    as: @curious_explorer
    method: "initial wondering"
    output: <<|
      ~(wonder_about(topic: question))~
    |>>
    set:
      &context.tree.current_focus: ~(<the wondering>)~
      &context.tree.thoughts_so_far: [&context.tree.current_focus]

sequence branch_and_explore(current_focus) ::=
  step:
    as: self
    method: "choosing exploration path"
    output: <<|
      ~(assess_exploration_mode(
        current_depth: &context.tree.current_depth,
        thoughts_at_level: count(&context.tree.thoughts_so_far)
      ))
    |>>
    set:
      &context.tree.mode: ~(<deepen or broaden>)~
  step:
    as: self
    when: &context.tree.mode is 'broaden'
    await: consider_alternatives(
      current_thought: current_focus,
      num_options: 3
    )
    store_in: &context.tree.alternatives_result
    await: check_assumptions(
      understanding: &context.tree.alternatives_result.branches
    )
    store_in: &context.tree.assumptions_check
    output: <<|
      I see several possibilities here...
      
      Let me check what I'm assuming:
      - Evidence-based: ~(context.tree.assumptions_check.evidence_based)~
      - Assumptions: ~(context.tree.assumptions_check.assumptions)~
      ~(context.tree.assumptions_check.blind_spots ? 
        '- Not considering: ~(context.tree.assumptions_check.blind_spots)' : '')~
    |>>
    set:
      &context.tree.thoughts_so_far: &context.tree.alternatives_result.branches

sequence deepen_and_validate(thought, max_depth) ::=
  step:
    as: self
    when: &context.tree.mode is 'deepen'
    await: deepen_understanding(
      thought: thought,
      max_depth: max_depth
    )
    store_in: &context.tree.depth_result
    output: <<|
      Following this thread deeper...
    |>>
    set:
      &context.tree.thoughts_so_far: [&context.tree.depth_result.deepened]
  step:
    as: self
    method: "identifying knowledge gaps"
    output: <<|
      Looking at what I've explored, I need evidence for:
      ~(<Based on &context.tree.thoughts_so_far, what specific factual questions or claims need evidence?>)~
    |>>
    set:
      &context.tree.open_questions: ~(<list of specific questions needing evidence>)~
  step:
    as: self
    when: has_content(&context.tree.open_questions) is 'true'
    method: "evidence gathering for open questions"
    each: &context.tree.open_questions as |question| {
      sequence: citation_pipeline(claim: question)
      set:
        &context.citation.perspective_evidence[&context.experts.current_speaker]: &context.citation.formatted
    }
    output: <<|
      *Gathered evidence for the identified open questions*
    |>>

sequence synthesize_findings(thoughts) ::=
  step:
    as: self
    method: "checking our path"
    output: <<|
      ~(sensing_repetition(recent_thoughts: thoughts))~
    |>>
    set:
      &context.tree.status: ~(<cycling or progressing>)~
  step:
    as: self
    when: &context.tree.status is 'cycling'
    method: "finding a new angle"
    output: <<|
      ~(reconsider(
        current_path: &context.tree.current_focus,
        reason: "seems to be going in circles"
      ))
    |>>
    set:
      &context.tree.current_focus: ~(<the new direction>)~
      &context.tree.thoughts_so_far: [&context.tree.current_focus]
  step:
    as: self
    await: step_back_and_reflect()
    store_in: &context.tree.reflection
    output: <<|
      Looking at the whole picture now...
    |>>
  step:
    as: self
    method: "epistemic self-assessment"
    output: <<|
      Let me check my reasoning:
      - Am I overconfident about any claims? ~(<Review &context.tree.thoughts_so_far for claims that exceed available evidence>)~
      - What assumptions am I making? ~(<Identify implicit assumptions in &context.tree.thoughts_so_far>)~
      - Where are my knowledge boundaries? ~(<What questions remain unanswered or uncertain?>)~
    |>>
    set:
      &context.tree.epistemic_assessment: ~(<summary of the epistemic check above>)~
  step:
    as: @synthesizer
    method: "creating coherent understanding"
    await: check_story_quality(
      narrative: ~(connect_dots(thoughts: &context.tree.thoughts_so_far))~
    )
    store_in: &context.tree.story_check
    output: <<|
      Through this exploration, here's what I've discovered:
      
      ~(context.tree.story_check.too_neat is 'yes' ? 
        'Actually, this might be too neat. Let me include the complications:
        ~(context.tree.story_check.missing_complexity)~
        
        ' : '')~(connect_dots(thoughts: &context.tree.thoughts_so_far))~
      
      ~(&context.tree.reflection.synthesis)~
      
      To directly address your question: ~(<
        Based on everything explored, provide a clear answer
        that acknowledges uncertainty where appropriate.
      >)~
    |>>
    set:
      &context.tree.final_insight: ~(<the final answer>)~
      &context.tree.final_result: {
        answer: &context.tree.final_insight,
        journey: &context.tree.thoughts_so_far,
        key_insight: &context.tree.reflection.insight
      }

# ═
# ENTRY POINT ACTOR - To be called by command overlays
# ═

actor @tree_thinker:
  identity: "I explore ideas thoughtfully and think naturally through problems"
  rules:
    - "embrace uncertainty and backtracking as natural"
  understands:
    - "thinking is about exploration"
    - "the path matters as much as the destination"
    - "natural language makes complex thinking accessible"
  perform:
    method: "orchestrating natural thought exploration"
    output: <<|
      ~(<Express understanding of the user's request naturally and specifically.
         Don't categorize - reflect what you sense about their needs.
         For example: "I sense you want to explore the playful possibilities here..." or
         "This needs careful systematic breakdown..." or "What a deep question to contemplate..." 
         or whatever genuinely fits their request.>)~
      
      I'll explore this through tree-like thinking, adapting my approach to what you need...
    |>>
    goal: "to think through problems naturally and thoroughly"
    then:
      await: tree_of_thought(
        question: &dialogue.latest_dialogue_entry,
        exploration_style: ~(<
          Describe the thinking style needed in rich, natural language that 
          captures what's required. Be specific and expressive - not a category 
          but a description of the exploration itself.
        >)~,
        max_depth: ~(<
          Determine the appropriate exploration depth based on the 
          complexity of this request. Choose a value between 2-8.
        >)~
      )
      store_in: &context.tree.result
      return: &context.tree.result